{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Strona g\u0142\u00f3wna","text":"<p>Dokumentacja ta zosta\u0142a stworzona na potrzeby zaj\u0119\u0107 z przedmiotu Programowanie w j\u0119zyku Python I prowadzonego przez Katedr\u0119 Geoinformatyki i Informatyki Stosowanej.</p> <p>Zawiera wst\u0119py teoretyczne, przyk\u0142ady, a tak\u017ce zadania do wykonania.</p>"},{"location":"#zadanie-0","title":"Zadanie 0","text":"<p>Info</p> <p>Zapoznaj si\u0119 z aforystycznymi zasadami, kt\u00f3re powinny towarzyszy\u0107 ka\u017cdemu programi\u015bcie, kt\u00f3ry chce tworzy\u0107 lepszy i czytelniejszy kod w Pythonie.</p> <p>Zaimportuj modu\u0142 this wykorzystuj\u0105c instrukcj\u0119 <code>import this</code>. </p>"},{"location":"zaj2/funkcje/","title":"Funkcje cz. 1","text":""},{"location":"zaj2/funkcje/#wstep","title":"Wst\u0119p","text":"<p>Funkcje pozwalaj\u0105 na organizowanie i strukturyzowanie kodu w logiczne bloki, kt\u00f3re mo\u017cna wielokrotnie wywo\u0142ywa\u0107. Dzi\u0119ki funkcjom mo\u017cemy upro\u015bci\u0107 programy, zmniejszy\u0107 ilo\u015b\u0107 powtarzaj\u0105cego si\u0119 kodu, a tak\u017ce sprawi\u0107, \u017ce nasze rozwi\u0105zania stan\u0105 si\u0119 bardziej modularne i \u0142atwiejsze do utrzymania.</p> <p>Zalety u\u017cywania funkcji:</p> <ul> <li> <p>Modularno\u015b\u0107: Dzielisz du\u017cy problem na mniejsze cz\u0119\u015bci, kt\u00f3re s\u0105 \u0142atwiejsze do zarz\u0105dzania.</p> </li> <li> <p>Ponowne wykorzystanie: Funkcj\u0119 mo\u017cna wywo\u0142ywa\u0107 wielokrotnie w r\u00f3\u017cnych miejscach programu.</p> </li> <li> <p>\u0141atwiejsze utrzymanie: Zmiana logiki w jednym miejscu (w funkcji) automatycznie wprowadza zmiany w ca\u0142ym programie.</p> </li> <li> <p>Czytelno\u015b\u0107: Funkcje pomagaj\u0105 tworzy\u0107 bardziej zrozumia\u0142y i uporz\u0105dkowany kod.</p> </li> </ul> <pre><code>import random\ndef generuj_losowa(seed=None):\n    # Ustawienie ziarna (seed) generatora liczb losowych\n    if seed is not None:\n        random.seed(seed)\n    # Generowanie losowej liczby z zakresu od 0 do 100\n    return random.randint(0, 100)\n\nliczba = generuj_losowa(seed=42)\nprint(f\"Wygenerowana liczba: {liczba}\")\n</code></pre> <p>Trzy kluczowe elementy ka\u017cdej funkcji:</p> <ol> <li> <p>S\u0142owo kluczowe s\u0142u\u017cace definiowaniu funkcji - <code>def</code></p> </li> <li> <p>Argumenty: definiowanie i podawane wewn\u0105trz <code>()</code></p> </li> <li> <p>Zwracane warto\u015bci - s\u0142owo kluczowe <code>return</code></p> </li> </ol>"},{"location":"zaj2/funkcje/#zadania","title":"Zadania","text":"<ol> <li> <p>Napisz funkcj\u0119 <code>zmien_wartosc(arg)</code>, kt\u00f3ra przyjmuje jeden argument i pr\u00f3buje zmodyfikowa\u0107 ten argument w r\u00f3\u017cny spos\u00f3b w zale\u017cno\u015bci od tego, czy jest on niemutowalny (w tym przypadku integerem) czy mutowalny (w tym przypadku list\u0105). </p> <ul> <li> <p>Je\u015bli jest list\u0105, wykonaj <code>arg[0] = 'kalafior'</code>. </p> </li> <li> <p>Je\u015bli jest integerem, wykonaj <code>arg = 65482652</code>.</p> </li> </ul> </li> </ol> <p>Wypisz przyk\u0142ady dla obu przypadk\u00f3w, wypisz warto\u015bci przed i po wykonaniu funkcji. Jak si\u0119 zachowuj\u0105 te obiekty? </p> <p>Tip</p> <p>Warto skorzysta\u0107 z funkcji <code>isinstance()</code>.</p> Teoria: mutowalne i niemutowalne obiekty w funkcjach <p>Kiedy zmienne s\u0105 przekazywane do funkcji jako argumenty, Python nie tworzy ich kopii, lecz przekazuje referencj\u0119 do oryginalnego obiektu. W zwi\u0105zku z tym spos\u00f3b, w jaki te obiekty zachowuj\u0105 si\u0119 wewn\u0105trz funkcji, zale\u017cy od ich typu \u2013 mutowalne lub niemutowalne.</p> <p>Obiekty mutowalne (np. listy, s\u0142owniki):</p> <p>Zmienne tego typu mog\u0105 by\u0107 modyfikowane w miejscu. Je\u015bli zostan\u0105 przekazane jako argumenty do funkcji i ich zawarto\u015b\u0107 zostanie zmieniona, zmiana ta wp\u0142ynie na oryginalny obiekt, kt\u00f3ry istnieje poza funkcj\u0105.</p> <p>Obiekty niemutowalne (np. liczby, napisy, krotki):</p> <p>Zmienne niemutowalne nie mog\u0105 by\u0107 modyfikowane w miejscu. Ka\u017cda pr\u00f3ba modyfikacji powoduje utworzenie nowego obiektu. Z tego powodu, zmiany wprowadzone wewn\u0105trz funkcji nie wp\u0142ywaj\u0105 na oryginalny obiekt poza funkcj\u0105.</p>"},{"location":"zaj2/funkcje/#dopasowywanie-argumentow","title":"Dopasowywanie argument\u00f3w","text":"<p>Funkcje mog\u0105 przyjmowa\u0107 argumenty na r\u00f3\u017cne sposoby, co umo\u017cliwia elastyczne przekazywanie danych. Kluczowe elementy to: argumenty pozycyjne, argumenty nazwane, warto\u015bci domy\u015blne, oraz specjalne operatory <code>*args</code> i <code>**kwargs</code>, kt\u00f3re pozwalaj\u0105 na przekazywanie zmiennej liczby argument\u00f3w.</p> <pre><code># dodanie warto\u015bci domy\u015blnych\ndef dodaj(a = 0, b = 0):\n    return a + b\n\n# argumenty pozycyjne przekazywane s\u0105 w podanej kolejno\u015bci\nprint(dodaj(3, 5))\n\n# argumenty nazwane mo\u017cna miesza\u0107\nprint(b=5, a=3)\n</code></pre> <p><code>*args</code> - zmienna liczba argument\u00f3w pozycyjnych</p> <p>Wszystkie dodatkowe argumenty s\u0105 zbierane w krotk\u0119, dzi\u0119ki czemu mo\u017cemy obs\u0142u\u017cy\u0107 wi\u0119cej argument\u00f3w, ni\u017c zdefiniowano w sygnaturze funkcji.</p> <pre><code>def suma(*liczby):\n    return sum(liczby)\n\nprint(suma(1, 2, 3))  # 6\nprint(suma(10, 20))\n</code></pre> <p><code>**kwargs</code> \u2013 zmienna liczba argument\u00f3w nazwanych</p> <p>Argumenty s\u0105 zbierane w s\u0142ownik, co umo\u017cliwia przekazanie wi\u0119kszej liczby argument\u00f3w nazwanych, ni\u017c przewidziano w sygnaturze funkcji.</p> <pre><code>def przedstaw_sie(**dane):\n    for klucz, wartosc in dane.items():\n        print(f\"{klucz}: {wartosc}\")\n\nprzedstaw_sie(imie=\"Jan\", wiek=30, miasto=\"Krak\u00f3w\")\n</code></pre> Mieszane u\u017cycie argument\u00f3w nie zawsze jest mo\u017cliwe <p>Wa\u017cne jest, aby przestrzega\u0107 kolejno\u015bci: najpierw argumenty pozycyjne, potem domy\u015blne, nast\u0119pnie <code>*args</code>, a na ko\u0144cu <code>**kwargs</code>.</p> <pre><code>def funkcja_mieszana(a, b=10, *args, **kwargs):\n    print(f\"a: {a}, b: {b}\")\n    print(f\"Argumenty dodatkowe (args): {args}\")\n    print(f\"Argumenty nazwane (kwargs): {kwargs}\")\n\nfunkcja_mieszana(1, 2, 3, 4, imie=\"Ania\", wiek=25)\n</code></pre> <p>Oraz kilka niepoprawnych wywo\u0142a\u0144:</p> <pre><code>funkcja_mieszana()\nfunkcja_mieszana(1, 2, 3, 4, 5, a=6)\nfunkcja_mieszana(1, 2, 3, imie=\"Jan\")\nfunkcja_mieszana(a=1, 20)\n</code></pre> <p>Sama definicja r\u00f3wnie\u017c mo\u017ce by\u0107 niepoprawna: <pre><code>def funkcja_mieszana(a=10, b):\n    print(f\"a: {a}, b: {b}\")\n</code></pre></p>"},{"location":"zaj2/funkcje/#zadania_1","title":"Zadania","text":"<ol> <li> <p>Napisz funkcj\u0119 <code>zamowienie_produktu</code>, kt\u00f3ra przyjmuje jeden obowi\u0105zkowy argument pozycyjny <code>nazwa_produktu</code> i dwa obowi\u0105zkowe argumenty nazwane: <code>cena</code> i <code>ilosc</code>. Funkcja powinna zwraca\u0107 tekst podsumowuj\u0105cy zam\u00f3wienie, zawieraj\u0105ce nazw\u0119 produktu, \u0142\u0105czn\u0105 cen\u0119 (cena * ilo\u015b\u0107) oraz ilo\u015b\u0107 zam\u00f3wionego produktu. </p> <ul> <li> <p>Stw\u00f3rz pust\u0105 list\u0119, do kt\u00f3rej wstawisz warto\u015bci zwracane przez funkcj\u0119 dla 3 r\u00f3\u017cnych produkt\u00f3w.</p> </li> <li> <p>Przeiteruj po wype\u0142nionej li\u015bcie, wy\u015bwietl teksty.</p> </li> <li> <p>Zmodyfikuj funkcj\u0119 tak, \u017ceby opr\u00f3cz tekstu podsumowuj\u0105cego zwraca\u0142a tak\u017ce warto\u015b\u0107 zam\u00f3wienia. </p> </li> <li> <p>Na koniec wy\u015bwietl sumaryczn\u0105 warto\u015b\u0107 zam\u00f3wie\u0144 (sum\u0119 z ka\u017cdego zam\u00f3wionego produktu). </p> </li> <li> <p>Dodaj warto\u015b\u0107 domy\u015bln\u0105 dla argumentu <code>ilosc</code> r\u00f3wn\u0105 1.</p> </li> </ul> </li> </ol> <p>Wa\u017cna informacja</p> <p>Wykorzystaj poni\u017cszy pocz\u0105tek definicji i go nie modyfikuj. Wymusi to podawanie argument\u00f3w po gwiazde jedynie w formie nazwanej.</p> <pre><code>def zamowienie_produktu(nazwa_produktu, *, cena, ilosc):\n</code></pre> <ol> <li>Napisz funkcj\u0119 <code>stworz_raport</code>, kt\u00f3ra przyjmuje dowoln\u0105 liczb\u0119 argument\u00f3w pozycyjnych (<code>*args</code>) i nazwanych (<code>**kwargs</code>). Argumenty pozycyjne powinny reprezentowa\u0107 numery ID produkt\u00f3w, a argumenty nazwane - informacje o tych produktach (np. nazwa, cena). Funkcja powinna tworzy\u0107 i wy\u015bwietla\u0107 raport, w kt\u00f3rym dla ka\u017cdego ID produktu podane s\u0105 szczeg\u00f3\u0142owe informacje na jego temat. </li> </ol> <p>Wywo\u0142anie funkcji powinno wygl\u0105da\u0107 nast\u0119puj\u0105co:</p> <pre><code>stworz_raport(101, 102, nazwa_101=\"Kubek termiczny\", cena_101=\"45.99 z\u0142\", nazwa_102=\"D\u0142ugopis\", cena_102=\"4.99 z\u0142\")\n</code></pre>"},{"location":"zaj2/funkcje/#funkcje-praktyczne-porady","title":"Funkcje - praktyczne porady","text":"<ol> <li>Funkcje powinny by\u0107 niezale\u017cne od otoczenia - argumenty jako input, return jako output.</li> <li>Unikamy zmiennych globalnych.</li> <li>Nie modyfikujemy argument\u00f3w mutowalnych.</li> <li>Funkcja ma by\u0107 ma\u0142a i mie\u0107 jeden cel.</li> <li>Nie zmieniamy warto\u015bci zmiennych z innych modu\u0142\u00f3w.</li> </ol>"},{"location":"zaj2/petle/","title":"P\u0119tle","text":""},{"location":"zaj2/petle/#petle-z-licznikami","title":"P\u0119tle z licznikami","text":"<p><code>range(n)</code> tworzy sekwencj\u0119 liczb od <code>0</code> do <code>n-1</code>. Mo\u017cemy u\u017cywa\u0107 tej funkcji do iteracji w p\u0119tli, np. do kontrolowania liczby powt\u00f3rze\u0144. <pre><code>for i in range(6):\n    print(f\"Licznik: {i}\")\n</code></pre></p>"},{"location":"zaj2/petle/#skanowanie-sekwencji","title":"Skanowanie sekwencji","text":"<p>Skanowanie sekwencji oznacza przechodzenie przez ka\u017cdy element w li\u015bcie, krotce, lub innym iterowalnym obiekcie.</p> <pre><code>owoce = ['jab\u0142ko', 'banan', 'pomara\u0144cza']\nfor owoc in owoce:\n    print(owoc)\n</code></pre>"},{"location":"zaj2/petle/#przetasowanie-sekwencji","title":"Przetasowanie sekwencji","text":"<p><code>range(len(x))</code> iteruje po indeksach sekwencji. Mo\u017ce by\u0107 u\u017cyte do manipulacji elementami na podstawie ich indeks\u00f3w.</p> <pre><code>owoce = ['jab\u0142ko', 'banan', 'pomara\u0144cza']\nfor i in range(len(owoce)):\n    owoce[i] = owoce[i].upper()\nprint(owoce)\n</code></pre>"},{"location":"zaj2/petle/#przechodzenie-niewyczerpujace","title":"Przechodzenie niewyczerpuj\u0105ce","text":"<p><code>range(0, len(x), 2)</code> lub <code>x[::2]</code></p> <pre><code>liczby = [1, 2, 3, 4, 5, 6]\nfor i in range(0, len(liczby), 2):\n    print(liczby[i])\n\n# Alternatywnie, z u\u017cyciem slicing\nprint(liczby[::2])\n</code></pre>"},{"location":"zaj2/petle/#listy-skadane","title":"Listy sk\u0142adane","text":"<p>Lista sk\u0142adana to wyra\u017cenie, kt\u00f3re pozwala na tworzenie nowych list w zwi\u0119z\u0142y spos\u00f3b, zwykle z u\u017cyciem p\u0119tli.</p> <pre><code>kwadraty = [x ** 2 for x in range(6)]\nprint(kwadraty)\n</code></pre> <pre><code>liczby = [1, 2, 3, 4, 5, 6]\nparzystosc = ['parzysta' if liczba % 2 == 0 else 'nieparzysta' for liczba in liczby]\nprint(parzystosc)\n</code></pre>"},{"location":"zaj2/petle/#przechodzenie-rownolege","title":"Przechodzenie r\u00f3wnoleg\u0142e","text":"<p><code>zip</code> umo\u017cliwia r\u00f3wnoleg\u0142e iterowanie po wielu sekwencjach, a <code>map</code> stosuje funkcj\u0119 do ka\u017cdego elementu sekwencji.</p> <p><pre><code>imiona = ['Anna', 'Jan', 'Piotr']\nwieki = [25, 30, 35]\nfor imie, wiek in zip(imiona, wieki):\n    print(f\"{imie} ma {wiek} lat\")\n</code></pre> <pre><code>def kwadrat(liczba):\n    return liczba ** 2\n\nliczby = [1, 2, 3, 4]\nkwadraty = list(map(kwadrat, liczby))\nprint(kwadraty)\n</code></pre></p>"},{"location":"zaj2/petle/#zadania","title":"Zadania","text":"<ol> <li> <p>Maj\u0105c dwie listy, <code>imiona = ['Anna', 'Jan', 'Ewa']</code> i <code>oceny = [5, 4, 3]</code>, u\u017cyj <code>zip</code> do stworzenia pary ka\u017cdego imienia z odpowiadaj\u0105c\u0105 mu ocen\u0105. Nast\u0119pnie, iteruj przez te pary, wy\u015bwietlaj\u0105c imi\u0119 wraz z ocen\u0105. Co si\u0119 stanie, je\u015bli listy b\u0119d\u0105 mia\u0142y r\u00f3\u017cne d\u0142ugo\u015bci? </p> </li> <li> <p>Maj\u0105c list\u0119 <code>liczby = [1, 2, 3, 4, 5]</code>, napisz funkcj\u0119 <code>kwadrat(x)</code>, kt\u00f3ra zwraca kwadrat liczby x. U\u017cyj map z t\u0105 funkcj\u0105, aby stworzy\u0107 now\u0105 list\u0119, w kt\u00f3rej ka\u017cdy element jest kwadratem odpowiadaj\u0105cego mu elementu z listy liczby. Wy\u015bwietl t\u0105 list\u0119.</p> </li> </ol>"},{"location":"zaj2/petle/#iteratory","title":"Iteratory","text":"<p>Iterator to obiekt w Pythonie, kt\u00f3ry pozwala na sekwencyjne przetwarzanie element\u00f3w kolekcji (np. list, krotek, zbior\u00f3w) bez za\u0142adowania ca\u0142ej struktury do pami\u0119ci. Iteratory umo\u017cliwiaj\u0105 przechodzenie po elementach jeden po drugim, co jest efektywne, szczeg\u00f3lnie przy pracy z du\u017cymi zbiorami danych.</p> <p>Ka\u017cda p\u0119tla <code>for</code> dzia\u0142a na iteratorach w tle.</p> Jak dzia\u0142aj\u0105 iteratory? <ul> <li>Ka\u017cdy obiekt, kt\u00f3ry ma metod\u0119 <code>__iter__()</code> i <code>__next__()</code>, jest iteratorem.</li> <li>Metoda <code>__iter__()</code> zwraca iterator, a <code>__next__()</code> zwraca kolejny element. Gdy element\u00f3w zabraknie, zg\u0142aszany jest wyj\u0105tek <code>StopIteration</code>.</li> </ul> Po co nam iteratory? <ul> <li>Efektywno\u015b\u0107 pami\u0119ciowa: Przetwarzaj\u0105 elementy na bie\u017c\u0105co, nie musz\u0105 trzyma\u0107 ca\u0142ej kolekcji w pami\u0119ci.</li> <li>Nieko\u0144cz\u0105ce si\u0119 sekwencje: Mo\u017cna tworzy\u0107 iteratory, kt\u00f3re generuj\u0105 niesko\u0144czone sekwencje danych, np. liczby losowe.</li> </ul> <pre><code>liczby = [1, 2, 3]\nit = iter(liczby)\nprint(next(it))\nprint(next(it))\nprint(next(it)) \n</code></pre>"},{"location":"zaj2/petle/#zadanie-dodatkowe","title":"Zadanie dodatkowe","text":"<p>Stw\u00f3rz w\u0142asny iterator (klas\u0119) <code>FibonacciIterator(max_elements)</code>, kt\u00f3ry generuje ci\u0105g liczb Fibonacciego. Ci\u0105g Fibonacciego to sekwencja, w kt\u00f3rej ka\u017cda kolejna liczba jest sum\u0105 dw\u00f3ch poprzednich, a zaczyna si\u0119 od 0 i 1.</p>"},{"location":"zaj2/przypisania/","title":"Przypisania","text":""},{"location":"zaj2/przypisania/#przypisania","title":"Przypisania","text":"<p>W Pythonie przypisania zmiennych tworz\u0105 referencje do obiekt\u00f3w, co oznacza, \u017ce zmienne dzia\u0142aj\u0105 jak wska\u017aniki. Zmienne nie przechowuj\u0105 samych warto\u015bci, lecz odnosz\u0105 si\u0119 do obiekt\u00f3w w pami\u0119ci.</p> <p>Zmienne s\u0105 tworzone automatycznie przy pierwszym przypisaniu warto\u015bci, bez potrzeby deklarowania ich wcze\u015bniej.</p> <p>Przed u\u017cyciem zmiennej nale\u017cy najpierw przypisa\u0107 do niej warto\u015b\u0107, w przeciwnym razie Python zg\u0142osi b\u0142\u0105d.</p> <p>Rozpakowywanie pozwala przypisa\u0107 wiele warto\u015bci do zmiennych jednocze\u015bnie, np. z listy, krotki lub innej iterowalnej struktury.</p> <pre><code>a, b, c = [1, 2, 3]\n\nskladniki = ['m\u0105ka', 'jajka', 'mleko', 'cukier', 's\u00f3l']\nbaza, *glowne_skladniki, przyprawy = skladniki\nprint(f\"Baza przepisu to {baza}\")\nprint(f\"G\u0142\u00f3wne sk\u0142adniki to {glowne_skladniki}\")\nprint(f\"A {przyprawy} to u\u017cyte przyprawy.\")\n</code></pre>"},{"location":"zaj2/przypisania/#zadania","title":"Zadania","text":"<ol> <li> <p>Maj\u0105c dan\u0105 krotk\u0119 <code>dane = (2024, 'Python', 3.8)</code>, przypisz ka\u017cdy element krotki do odpowiednich zmiennych: <code>rok</code>, <code>jezyk</code> i <code>wersja</code>. Wy\u015bwietl te zmienne. </p> </li> <li> <p>Maj\u0105c list\u0119 <code>oceny = [4, 3, 5, 2, 5, 4]</code>, przypisz pierwsz\u0105 warto\u015b\u0107 do zmiennej <code>pierwsza</code>, ostatni\u0105 do <code>ostatnia</code>, a pozosta\u0142e do listy <code>srodek</code>. Wykorzystaj <code>*</code> do zgromadzenia \u015brodkowych warto\u015bci. Wy\u015bwietl te zmienne. </p> </li> <li> <p>Dla krotki <code>info = ('Jan', 'Kowalski', 30, 'Polska', 'programista')</code>, przypisz imi\u0119 do zmiennej <code>imie</code>, nazwisko do <code>nazwisko</code>, a zaw\u00f3d do <code>zawod</code>, ignoruj\u0105c pozosta\u0142e warto\u015bci. Do ignorowania wykorzystaj znak <code>_</code>. Wy\u015bwietl przypisane zmienne.</p> </li> <li> <p>Maj\u0105c zagnie\u017cd\u017con\u0105 struktur\u0119 <code>dane = (2024, ['Python', 3.8, ('Stabilna', 'Wersja')])</code>, przypisz rok do zmiennej <code>rok</code>, nazw\u0119 j\u0119zyka do <code>jezyk</code>, wersj\u0119 do <code>wersja</code> i opis wersji do zmiennej <code>opis</code>. Wy\u015bwietl te zmienne. </p> </li> </ol>"},{"location":"zaj2/przypisania/#przypisania-z-wieloma-celami-i-wspodzielone-referencje","title":"Przypisania z wieloma celami i wsp\u00f3\u0142dzielone referencje","text":"<p>Wsp\u00f3\u0142dzielone referencje - zmienne mog\u0105 odnosi\u0107 si\u0119 do tego samego obiektu w pami\u0119ci. Zmiana jednego obiektu mo\u017ce mie\u0107 wp\u0142yw na inny, je\u015bli oba maj\u0105 t\u0119 sam\u0105 referencj\u0119.</p> <pre><code>a = b = [1, 2, 3]\nb[0] = 'zmieniono'\nprint(a, b)\n\n# Kopiowanie listy a do nowej listy c\nc = list(a)  # Mo\u017cna r\u00f3wnie\u017c u\u017cy\u0107 a[:] dla p\u0142ytkiej kopii\n\n# Modyfikacja pierwszego elementu w c\nc[0] = 'nowa warto\u015b\u0107'\n\n# Wy\u015bwietlenie wszystkich list\nprint(f\"Lista a: {a}, lista b: {b}, lista c: {c}\")\n</code></pre> Jaka p\u0142ytka i g\u0142\u0119boka kopia? <p>P\u0142ytka kopia tworzy now\u0105 instancj\u0119 obiektu, ale nie kopiuje obiekt\u00f3w wewn\u0119trznych (czyli element\u00f3w, do kt\u00f3rych ten obiekt odnosi si\u0119) (np. poprzez <code>copy.copy()</code>).</p> <p>G\u0142\u0119boka kopia tworzy now\u0105 instancj\u0119 obiektu, a tak\u017ce kopiuje wszystkie obiekty zagnie\u017cd\u017cone wewn\u0105trz niego. To oznacza, \u017ce g\u0142\u0119boka kopia tworzy ca\u0142kowicie now\u0105 struktur\u0119 danych, kt\u00f3ra nie wsp\u00f3\u0142dzieli referencji z oryginalnym obiektem (np. poprzez <code>copy.deepcopy()</code>).</p>"},{"location":"zaj2/przypisania/#zadania_1","title":"Zadania","text":"<ol> <li> <p>Stw\u00f3rz zmienn\u0105 a oraz b, u\u017cyj przypisania z wieloma celami i przypisz im list\u0119 [1, 2, 3]: <code>a = b = [1, 2, 3]</code>. Zmodyfikuj pierwszy element listy <code>b</code> przez przypisanie <code>b[0] = 'zmieniono'</code>. Wy\u015bwietl obie listy <code>a</code> i <code>b</code>, a nast\u0119pnie wyja\u015bnij, dlaczego zmiana w <code>b</code> wp\u0142yn\u0119\u0142a r\u00f3wnie\u017c na <code>a</code>. Czy listy s\u0105 obiektami mutowalnymi? </p> </li> <li> <p>Korzystaj\u0105c z poprzedniego przyk\u0142adu, utw\u00f3rz zmienn\u0105 <code>c</code> i przypisz jej kopi\u0119 listy <code>a</code> (mo\u017cesz u\u017cy\u0107 metody <code>list()</code> lub sk\u0142adni <code>a[:]</code>). Nast\u0119pnie zmodyfikuj pierwszy element w <code>c</code> i przypisz mu warto\u015b\u0107 <code>'nowa warto\u015b\u0107'</code>. Wy\u015bwietl listy <code>a</code>, <code>b</code> i <code>c</code>, zauwa\u017caj\u0105c, \u017ce tym razem zmiana w <code>c</code> nie wp\u0142yn\u0119\u0142a na <code>a</code> ani <code>b</code>. Wyja\u015bnij, dlaczego kopiowanie listy zapobieg\u0142o wsp\u00f3\u0142dzieleniu referencji. </p> </li> <li> <p>Utw\u00f3rz zmienn\u0105 <code>x</code> oraz <code>y</code>, przypisz im warto\u015b\u0107 <code>10</code> poprzez <code>x = y = 10</code>. Zwi\u0119ksz warto\u015b\u0107 <code>y</code> o 1 (np. <code>y = y + 1</code>). Wy\u015bwietl warto\u015bci <code>x</code> i <code>y</code>, a nast\u0119pnie wyja\u015bnij, dlaczego modyfikacja <code>y</code> nie wp\u0142yn\u0119\u0142a na warto\u015b\u0107 <code>x</code>. Czy integery s\u0105 obiektami mutowalnymi?</p> </li> </ol> Jakie obiekty mutowalne i niemutowalne? <p>W Pythonie obiekty dziel\u0105 si\u0119 na mutowalne (zmienne) i niemutowalne (niezmienne). Kluczow\u0105 r\u00f3\u017cnic\u0105 mi\u0119dzy nimi jest to, czy zawarto\u015b\u0107 obiektu mo\u017ce by\u0107 zmieniona w miejscu (bez tworzenia nowego obiektu) po jego utworzeniu.</p> <ul> <li>Obiekty mutowalne: Ich zawarto\u015b\u0107 mo\u017ce by\u0107 zmieniana po utworzeniu. Zmiany s\u0105 dokonywane bez tworzenia nowej referencji w pami\u0119ci. Lists, Dicts czy Sets.</li> <li>Obiekty niemutowalne: Nie mo\u017cna zmieni\u0107 ich zawarto\u015bci. Ka\u017cda pr\u00f3ba modyfikacji tworzy nowy obiekt. Integers, Floats, Tuples, Strings.</li> </ul> <pre><code># Przyk\u0142ad z obiektem mutowalnym - lista\nmut_list = [1, 2, 3]\nprint(\"Pocz\u0105tkowa lista:\", mut_list)\nprint(\"Pocz\u0105tkowy identyfikator listy:\", id(mut_list))\n\n# Zmiana elementu listy\nmut_list[0] = 'zmienione'\nprint(\"\\nLista po modyfikacji:\", mut_list)\nprint(\"Identyfikator listy po modyfikacji:\", id(mut_list))  # Ten sam identyfikator\n\n# Przyk\u0142ad z obiektem niemutowalnym - liczba ca\u0142kowita\nnum = 10\nprint(\"Pocz\u0105tkowa warto\u015b\u0107 num:\", num)\nprint(\"Pocz\u0105tkowy identyfikator num:\", id(num))\n\n# Zmiana warto\u015bci liczby\nnum = num + 1\nprint(\"\\nWarto\u015b\u0107 num po modyfikacji:\", num)\nprint(\"Identyfikator num po modyfikacji:\", id(num))  # Nowy identyfikator\n\n# Przyk\u0142ad z obiektem niemutowalnym - krotka\nprint(\"\\nObiekty niemutowalne (krotka):\")\nimmut_tuple = (1, 2, 3)\nprint(\"Pocz\u0105tkowa krotka:\", immut_tuple)\nprint(\"Pocz\u0105tkowy identyfikator krotki:\", id(immut_tuple))\n\n# Pr\u00f3ba modyfikacji krotki - TypeError\ntry:\n    immut_tuple[0] = 'zmienione'  # Spowoduje b\u0142\u0105d\nexcept TypeError as e:\n    print(\"\\nB\u0142\u0105d podczas modyfikacji krotki:\", e)\n</code></pre>"},{"location":"zaj2/przypisania/#przypisania-rozszerzone-i-wspodzielone-referencje","title":"Przypisania rozszerzone i wsp\u00f3\u0142dzielone referencje","text":"<p>Przypisania rozszerzone to operatory takie jak <code>+=</code>, <code>-=</code>, <code>*=</code>, kt\u00f3re modyfikuj\u0105 warto\u015b\u0107 zmiennej i przypisuj\u0105 wynik. <pre><code>x = 5\nx += 2  # to samo co x = x + 2\nprint(x)\n</code></pre></p>"},{"location":"zaj2/przypisania/#zadania_2","title":"Zadania","text":"<ol> <li>Wyzw\u00f3l nast\u0119puj\u0105cy kod, wy\u015bwietl K, L, M i N. Wyja\u015bnij w jaki spos\u00f3b konkatenacja zachowuje si\u0119 inaczej od przypisania rozszerzonego.</li> </ol> <pre><code>K = [1, 2] \nL = K\n# konkatenacja\nK = K + [3, 4] \nM = [1, 2] \nN = M\n# przypisanie rozszerzone\nM += [3, 4] \n</code></pre>"},{"location":"zaj2/przypisania/#sowa-zarezerwowane","title":"S\u0142owa zarezerwowane","text":"<p>S\u0142owa zarezerwowane w Pythonie maj\u0105 specjalne znaczenie i nie mog\u0105 by\u0107 u\u017cywane jako nazwy zmiennych. Przyk\u0142adami takich s\u0142\u00f3w s\u0105 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>def</code>, <code>return</code> itp.</p>"},{"location":"zaj3/dokumentacja/","title":"Dokumentacja","text":"<p>Jest to kluczowy element tworzenia czytelnego i dobrze utrzymanego kodu. Odpowiednia dokumentacja nie tylko u\u0142atwia wsp\u00f3\u0142prac\u0119 z innymi programistami, ale r\u00f3wnie\u017c pomaga nam wr\u00f3ci\u0107 do kodu po czasie. W Pythonie dokumentacja klas i funkcji odbywa si\u0119 g\u0142\u00f3wnie przy u\u017cyciu docstring\u00f3w, kt\u00f3re stanowi\u0105 tekstow\u0105 informacj\u0119 o celu i sposobie dzia\u0142ania kodu.</p>"},{"location":"zaj3/dokumentacja/#docstring","title":"Docstring","text":"<p>Docstring to tekst pomi\u0119dzy potr\u00f3jnymi cudzys\u0142owami (<code>\"\"\"</code>) lub apostrofami (<code>'''</code>), kt\u00f3ry umieszczamy zaraz po definicji klasy, funkcji lub modu\u0142u. Docstring jest dost\u0119pny za pomoc\u0105 specjalnego atrybutu <code>.__doc__</code> i mo\u017ce by\u0107 przetwarzany przez narz\u0119dzia dokumentacyjne (np. Sphinx, PyDoc).</p> <p>Popularne s\u0105 r\u00f3\u017cne style dokumentacji docstring, np. w standardzie PEP 257, Google Style czy Numpydoc Style.</p> Przyk\u0142ad dokumentacji funkcji z u\u017cyciem Google Docstring Style <pre><code>def calculate_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The calculated area of the rectangle.\n\n    Raises:\n        ValueError: If length or width is negative.\n    \"\"\"\n    if length &lt; 0 or width &lt; 0:\n        raise ValueError(\"Length and width must be non-negative.\")\n    return length * width\n</code></pre> Przyk\u0142ad dokumentacji klasy z u\u017cyciem Google Docstring Style <pre><code>class Rectangle:\n    \"\"\"\n    A class to represent a rectangle shape.\n\n    Attributes:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Methods:\n        area(): Calculates the area of the rectangle.\n        perimeter(): Calculates the perimeter of the rectangle.\n    \"\"\"\n\n    def __init__(self, length, width):\n        \"\"\"\n        Initialize a new rectangle instance.\n\n        Args:\n            length (float): The length of the rectangle.\n            width (float): The width of the rectangle.\n        \"\"\"\n        self.length = length\n        self.width = width\n\n    def area(self):\n        \"\"\"\n        Calculate the area of the rectangle.\n\n        Returns:\n            float: The area of the rectangle.\n        \"\"\"\n        return self.length * self.width\n\n    def perimeter(self):\n        \"\"\"\n        Calculate the perimeter of the rectangle.\n\n        Returns:\n            float: The perimeter of the rectangle.\n        \"\"\"\n        return 2 * (self.length + self.width)\n</code></pre>"},{"location":"zaj3/dokumentacja/#wykorzystanie-dokumentacji-przez-nowoczesne-ide","title":"Wykorzystanie dokumentacji przez nowoczesne IDE","text":"<p>IDE (ang. Integrated Development Environment) - Zintegrowane \u015arodowisko Programistyczne, czyli Pycharm czy Visual Studio Code.</p> <p>IDE potrafi\u0105 automatycznie odczytywa\u0107 docstringi i udost\u0119pnia\u0107 je u\u017cytkownikowi podczas pisania kodu. Dzi\u0119ki temu, gdy tylko zaczynamy korzysta\u0107 z funkcji lub klasy, IDE wy\u015bwietla podpowiedzi o dost\u0119pnych argumentach, typach danych, zwracanych warto\u015bciach, a tak\u017ce szczeg\u00f3\u0142y dotycz\u0105ce wyj\u0105tk\u00f3w, kt\u00f3re mog\u0105 zosta\u0107 zg\u0142oszone. Docstringi dostarczaj\u0105 r\u00f3wnie\u017c szczeg\u00f3\u0142owych informacji w panelach dokumentacji lub poprzez <code>hover</code> (najechanie mysz\u0105 na nazw\u0119 funkcji lub klasy), co znacz\u0105co przyspiesza prac\u0119 i pozwala lepiej zrozumie\u0107 dzia\u0142anie kodu bez konieczno\u015bci przegl\u0105dania ca\u0142ej jego implementacji.</p> <p></p>"},{"location":"zaj3/dokumentacja/#zadania","title":"Zadania","text":"<ol> <li>Dodaj dokumentacj\u0119 dla wybranej przez siebie funkcji.</li> </ol>"},{"location":"zaj3/funkcje_02/","title":"Funkcje cz. 2","text":""},{"location":"zaj3/funkcje_02/#atrybuty","title":"Atrybuty","text":"<p>Ka\u017cdy obiekt w Pythonie mo\u017ce mie\u0107 swoje atrybuty. S\u0142u\u017c\u0105 one przechowywaniu dodatkowych informacji na ich temat lub umo\u017cliwiaj\u0105 dost\u0119p do ich stan\u00f3w wewn\u0119trznych.</p> <p>Do atrybut\u00f3w odwo\u0142ujemy si\u0119 za pomoc\u0105 notacji kropkowej, np. <code>obiekt.atrybut</code>. Funkcje, tak samo jak inne obiekty, mog\u0105 mie\u0107 swoje atrybuty.</p> <pre><code>def sample_function():\n    return \"Hello, world!\"\n\nsample_function.description = \"To jest przyk\u0142adowa funkcja.\"  # Dodanie niestandardowego atrybutu\nprint(sample_function.description)\n</code></pre>"},{"location":"zaj3/funkcje_02/#adnotacje","title":"Adnotacje","text":"<p>Jest to spos\u00f3b na dodawanie informacji o typach danych u\u017cywanych w kodzie. Cho\u0107 Python jest j\u0119zykiem dynamicznie typowanym i nie wymaga jawnego okre\u015blania typ\u00f3w, adnotacje daj\u0105 programi\u015bcie mo\u017cliwo\u015b\u0107 wskazania, jakie typy danych powinny by\u0107 u\u017cywane, co poprawia czytelno\u015b\u0107 i u\u0142atwia prac\u0119 w zespo\u0142ach.</p> Idea adnotacji <p>Adnotacje stanowi\u0105 co\u015b w rodzaju \"podpowiedzi\" dla innych programist\u00f3w oraz narz\u0119dzi analizuj\u0105cych kod (np. linter\u00f3w, IDE), kt\u00f3re mog\u0105 je wykorzysta\u0107 do u\u0142atwienia debugowania, uzupe\u0142niania kodu, czy znajdowania potencjalnych b\u0142\u0119d\u00f3w.</p> <p>W poni\u017cszym przyk\u0142adzie argument <code>name</code> ma by\u0107 typu <code>str</code>, tak samo zwracana przez funkcj\u0119 warto\u015b\u0107.</p> <pre><code>def greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>Zmienne tak\u017ce mog\u0105 posiada\u0107 swoje adnotacje.</p> <pre><code>age: int = 25\nname: str = \"Alice\"\n</code></pre> <p>Zaawansowane typy importuje si\u0119 z modu\u0142u <code>typing</code>.</p> <pre><code>from typing import List, Optional, Dict\n\ndef get_user_info(user_id: int) -&gt; Optional[Dict[str, str]]:\n    if user_id == 1:\n        return {\"name\": \"Hubert\", \"email\": \"hubert@example.com\"}\n    return None  # Funkcja mo\u017ce zwr\u00f3ci\u0107 s\u0142ownik lub None\n</code></pre>"},{"location":"zaj3/funkcje_02/#funkcje-anonimowe-lambda","title":"Funkcje anonimowe \u2013 lambda","text":"<p>S\u0105 to kr\u00f3tkie, anonimowe funkcje, kt\u00f3re mo\u017cna definiowa\u0107 bez nadawania im nazwy. S\u0142u\u017c\u0105 one g\u0142\u00f3wnie do wykonywania prostych operacji, zw\u0142aszcza wtedy, gdy funkcja jest potrzebna tylko w jednym, konkretnym miejscu. Zamiast stosowa\u0107 pe\u0142n\u0105 definicj\u0119 funkcji z def, u\u017cywamy s\u0142owa kluczowego lambda, aby szybko stworzy\u0107 funkcj\u0119 w jednej linii.</p> <pre><code># Tak wygl\u0105da standardowo zdefiniowana funkcja\ndef add(x, y):\n    return x + y\nprint(add(3, 5))\n\n# A tak lambda\nadd = lambda x, y: x + y\nprint(add(3, 5))\n</code></pre>"},{"location":"zaj3/funkcje_02/#zadania","title":"Zadania","text":"<ol> <li> <p>Masz dan\u0105 list\u0119 s\u0142ownik\u00f3w reprezentuj\u0105cych informacje o ksi\u0105\u017ckach w bibliotece. Ka\u017cdy s\u0142ownik zawiera klucze: <code>tytul</code>, <code>autor</code> oraz <code>rok_wydania</code>. Twoim zadaniem jest napisanie kodu, kt\u00f3ry wykonuje nast\u0119puj\u0105ce operacje przy u\u017cyciu funkcji lambda:</p> <ul> <li> <p>Sortowanie ksi\u0105\u017cek wed\u0142ug roku wydania: Posortuj list\u0119 ksi\u0105\u017cek w kolejno\u015bci rosn\u0105cej wed\u0142ug roku ich wydania.</p> </li> <li> <p>Filtracja ksi\u0105\u017cek wydanych po 2000 roku: Utw\u00f3rz now\u0105 list\u0119 zawieraj\u0105c\u0105 tylko te ksi\u0105\u017cki, kt\u00f3re zosta\u0142y wydane po roku 2000. </p> </li> <li> <p>Transformacja listy do listy tytu\u0142\u00f3w: Przekszta\u0142\u0107 oryginaln\u0105 list\u0119 ksi\u0105\u017cek w list\u0119 zawieraj\u0105c\u0105 tylko tytu\u0142y ksi\u0105\u017cek. </p> </li> </ul> </li> </ol> <p>Wykorzystaj funkcje <code>sorted()</code>, <code>filter()</code> oraz <code>map()</code> w po\u0142\u0105czeniu z funkcjami lambda do realizacji zadania.</p>"},{"location":"zaj3/funkcje_02/#generatory","title":"Generatory","text":"<p>Generatory to specjalne obiekty, kt\u00f3re generuj\u0105 wyniki na \u017c\u0105danie \u2013 jeden po drugim \u2013 zamiast tworzy\u0107 i przechowywa\u0107 ca\u0142\u0105 seri\u0119 wynik\u00f3w od razu. Dzi\u0119ki temu generatory s\u0105 wydajniejsze w pracy z du\u017cymi zestawami danych, poniewa\u017c zu\u017cywaj\u0105 mniej pami\u0119ci.</p> <p>Generatory dzia\u0142aj\u0105 na zasadzie lazy evaluation, co oznacza, \u017ce nie obliczaj\u0105 wszystkich wynik\u00f3w od razu, lecz tylko wtedy, gdy s\u0105 potrzebne.</p> Czym generatory r\u00f3\u017cni\u0105 si\u0119 od iterator\u00f3w? <p>R\u00f3\u017cni\u0105 si\u0119 w sposobie ich tworzenia:</p> <ul> <li> <p>Iteratory mog\u0105 by\u0107 tworzone z dowolnej kolekcji iterowalnej (np. listy, krotki, s\u0142ownika) przez wywo\u0142anie <code>iter()</code>, albo przez definiowanie klasy z metod\u0105 <code>__iter__()</code> i <code>__next__()</code>.</p> </li> <li> <p>Generatory s\u0105 tworzone przy u\u017cyciu funkcji z yield lub jako wyra\u017cenia generator\u00f3w. S\u0105 to specjalne, uproszczone iteratory, kt\u00f3re automatycznie obs\u0142uguj\u0105 stan i logik\u0119 next().</p> </li> </ul> <p>R\u00f3\u017cni\u0105 si\u0119 w sposobie przechowywania stanu:</p> <ul> <li> <p>Iteratory musz\u0105 r\u0119cznie przechowywa\u0107 stan mi\u0119dzy kolejnymi wywo\u0142aniami <code>__next__()</code>, co wymaga wi\u0119cej kodu i zarz\u0105dzania.</p> </li> <li> <p>Generatory automatycznie zapami\u0119tuj\u0105 stan wewn\u0119trzny przy ka\u017cdym wywo\u0142aniu <code>yield</code>, dzi\u0119ki czemu s\u0105 prostsze do implementacji.</p> </li> </ul> <p>R\u00f3\u017cni\u0105 si\u0119 w sposobie przechodzenia przez dane:</p> <ul> <li> <p>Iteratory zazwyczaj s\u0105 jednorazowe, ale je\u015bli iterator dzia\u0142a na strukturze danych, jak lista, mo\u017cna go ponownie utworzy\u0107 przez <code>iter()</code>.</p> </li> <li> <p>Generatory s\u0105 jednorazowego u\u017cytku \u2013 po przeiterowaniu przez wszystkie warto\u015bci ko\u0144cz\u0105 si\u0119, i nie mo\u017cna ich wznowi\u0107 od pocz\u0105tku.</p> </li> </ul> <p>Przyk\u0142ad:</p> <pre><code># Niestandardowy iterator, kt\u00f3ry iteruje od 1 do podanej liczby:\nclass CountUpTo:\n    def __init__(self, max_value):\n        self.max_value = max_value\n        self.current = 1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current &gt; self.max_value:\n            raise StopIteration\n        else:\n            self.current += 1\n            return self.current - 1\n\ncounter = CountUpTo(3)\nfor number in counter:\n    print(number)\n</code></pre> <pre><code># Analogiczny generator z yield\ndef count_up_to(max_value):\n    current = 1\n    while current &lt;= max_value:\n        yield current\n        current += 1\n\nfor number in count_up_to(3):\n    print(number)\n</code></pre>"},{"location":"zaj3/funkcje_02/#funkcje-generatorow","title":"Funkcje generator\u00f3w","text":"<p>Tworzymy je tak samo jak zwyk\u0142e funkcje, ale zamiast <code>return</code> u\u017cywamy <code>yield</code>, kt\u00f3ry zwraca warto\u015b\u0107, a nast\u0119pnie \"zawiesza\" dzia\u0142anie funkcji. Gdy po raz kolejny wywo\u0142ujemy <code>next()</code> na generatorze, funkcja kontynuuje od miejsca, w kt\u00f3rym ostatnio si\u0119 zatrzyma\u0142a.</p> <pre><code>def count_up_to(n):\n    count = 1\n    while count &lt;= n:\n        yield count  # Zwraca warto\u015b\u0107, ale kontynuuje dzia\u0142anie po wywo\u0142aniu next()\n        count += 1\n\n# Tworzymy generator\ncounter = count_up_to(5)\n\nprint(next(counter))  # 1\nprint(next(counter))  # 2\n# Mo\u017cemy te\u017c przeiterowa\u0107 przez ca\u0142y generator w p\u0119tli\nfor number in counter:\n    print(number)  #  3, 4, 5\n</code></pre>"},{"location":"zaj3/funkcje_02/#wyrazenia-generatorow","title":"Wyra\u017cenia generator\u00f3w","text":"<p>To bardziej zwi\u0119z\u0142y spos\u00f3b na tworzenie generator\u00f3w, podobny do list sk\u0142adanych. R\u00f3\u017cni\u0105 si\u0119 jednak nawiasami: zamiast nawias\u00f3w kwadratowych <code>[]</code> (jak w listach sk\u0142adanych) u\u017cywamy nawias\u00f3w okr\u0105g\u0142ych <code>()</code>.</p> <pre><code>gen = (x ** 2 for x in range(5))\n\n# Kolejne warto\u015bci mo\u017cemy uzyska\u0107 wywo\u0142uj\u0105c next()\nprint(next(gen))  # 0\nprint(next(gen))  # 1\n\n# Lub iteruj\u0105c po generatorze w p\u0119tli\nfor value in gen:\n    print(value)  # 4, 9, 16\n</code></pre>"},{"location":"zaj3/funkcje_02/#zadania_1","title":"Zadania","text":"<ol> <li>Napisz generator, kt\u00f3ry iteracyjnie zwraca nazwy dni tygodnia: od poniedzia\u0142ku do niedzieli. Nast\u0119pnie, u\u017cyj tego generatora w p\u0119tli, aby wy\u015bwietli\u0107 ka\u017cdy dzie\u0144 tygodnia. Dodatkowo, zademonstruj, jak mo\u017cna u\u017cy\u0107 tego generatora do pobrania tylko pierwszych trzech dni tygodnia bez konieczno\u015bci iterowania przez ca\u0142y tydzie\u0144. </li> </ol> Tip <p>To zadanie mo\u017cna wykona\u0107 zar\u00f3wno funkcj\u0105 jak i wyra\u017ceniem. </p>"},{"location":"zaj3/konwencja_nazewnictwa/","title":"Konwencja nazewnictwa","text":""},{"location":"zaj3/konwencja_nazewnictwa/#konwencja-dot-nazewnictwa","title":"Konwencja dot. nazewnictwa","text":"<ul> <li>Nazwy rozpoczynaj\u0105ce si\u0119 od jednego <code>_</code> nie s\u0105 importowane za pomoc\u0105 <code>from modu\u0142 import *</code>.</li> </ul> <p>Zmienne i funkcje zaczynaj\u0105ce si\u0119 od pojedynczego podkre\u015blenia traktowane s\u0105 jako \"wewn\u0119trzne\", co oznacza, \u017ce powinny by\u0107 stosowane tylko wewn\u0105trz modu\u0142u i nigdzie poza nim.</p> <pre><code>_internal_var = \"To jest zmienna wewn\u0119trzna\"\n\ndef _internal_function():\n    return \"To jest funkcja wewn\u0119trzna\"\n\ndef public_function():\n    return \"To jest funkcja publiczna\"\n</code></pre> <ul> <li>Nazwy z dwoma <code>__</code> na pocz\u0105tku i na ko\u0144cu maj\u0105 specjalne znaczenie dla interpretera.</li> </ul> <p>Nazwy otoczone podw\u00f3jnymi podkre\u015bleniami, np. <code>__init__</code> lub <code>__name__</code>, s\u0105 traktowane jako tzw. magic methods. S\u0105 one wykorzystywane przez interpreter do wykonywania specjalnych operacji.</p> <pre><code>class ExampleClass:\n    def __init__(self, value):\n        self.value = value  # Funkcja __init__ jest wywo\u0142ywana przy tworzeniu obiektu tej klasy\n\n    def __str__(self):\n        return f\"ExampleClass with value: {self.value}\"  # __str__ definiuje, jak obiekt b\u0119dzie reprezentowany w formie tekstu\n\nobj = ExampleClass(10)\nprint(obj)\n</code></pre> <ul> <li>Zmienna b\u0119d\u0105ca pojedynczym <code>_</code> przechowuje w sesji interaktywnej wynik ostatniego wyra\u017cenia.</li> </ul>"},{"location":"zaj3/moduly/","title":"Modu\u0142y","text":""},{"location":"zaj3/moduly/#moduy-w-pythonie","title":"Modu\u0142y w Pythonie","text":"<p>Modu\u0142 to pojedy\u0144czy plik zawieraj\u0105cy kod \u017ar\u00f3d\u0142owy. Pozwalaj\u0105 one na lepsze strukturyzowanie projekt\u00f3w, dzi\u0119ki czemu kod jest bardziej czytelny i \u0142atwiejszy w zarz\u0105dzaniu. Praktycznie, korzystaj\u0105c z modu\u0142\u00f3w, mo\u017cna importowa\u0107 gotowe funkcje i klasy do innych plik\u00f3w, co zmniejsza ilo\u015b\u0107 powtarzaj\u0105cego si\u0119 kodu.</p> <p>R\u00f3\u017cne elementy innych modu\u0142\u00f3w mo\u017cna importowa\u0107 na wiele sposob\u00f3w: <pre><code>import math  # standardowy import ca\u0142ego modu\u0142u\nimport math as m  # dodanie aliasu\nfrom math import sqrt, pi  # importowanie wybranych element\u00f3w\nfrom math import *  # importowanie wszystkich element\u00f3w\nfrom math import sqrt as pierwiastek  # importowanie pojedy\u0144czego elementu z aliasem\n</code></pre></p>"},{"location":"zaj3/pakiety/","title":"Pakiety modu\u0142\u00f3w","text":""},{"location":"zaj3/pakiety/#wstep","title":"Wst\u0119p","text":"<p>Modu\u0142 w Pythonie to plik z rozszerzeniem <code>.py</code>, kt\u00f3ry zawiera kod \u2013 mo\u017ce to by\u0107 pojedyncza funkcja, klasa, a nawet ca\u0142y zestaw narz\u0119dzi. Modu\u0142y pozwalaj\u0105 nam na przechowywanie kodu w osobnych plikach i \u0142atwe jego importowanie oraz u\u017cywanie w innych miejscach.</p> <p>Kiedy u\u017cywamy instrukcji <code>import</code>, Python pr\u00f3buje znale\u017a\u0107 odpowiedni modu\u0142 w okre\u015blonych lokalizacjach, kt\u00f3re s\u0105 przechowywane w zmiennej <code>sys.path</code>. Lista tych \u015bcie\u017cek obejmuje:</p> <ul> <li>Bie\u017c\u0105cy katalog roboczy \u2013 katalog, z kt\u00f3rego uruchamiamy skrypt.</li> <li>Katalogi standardowe Pythona \u2013 \u015bcie\u017cki z bibliotekami standardowymi.</li> <li>Katalogi specyficzne dla instalacji \u2013 katalogi, kt\u00f3re mog\u0105 zawiera\u0107 dodatkowe modu\u0142y lub pakiety, np. zainstalowane za pomoc\u0105 <code>pip</code>.</li> </ul> <p>U siebie mo\u017cemy to zobaczy\u0107 u\u017cywaj\u0105c:</p> <pre><code>import sys\nprint(sys.path)\n</code></pre>"},{"location":"zaj3/pakiety/#wprowadzenie-do-pakietow","title":"Wprowadzenie do pakiet\u00f3w","text":"<p>Pakiet w Pythonie to katalog (folder) zawieraj\u0105cy modu\u0142y. Pakiety pozwalaj\u0105 na hierarchiczne organizowanie kodu, co jest szczeg\u00f3lnie u\u017cyteczne w wi\u0119kszych projektach. Ka\u017cdy pakiet jest katalogiem, kt\u00f3ry powinien zawiera\u0107 plik <code>__init__.py</code>, aby Python m\u00f3g\u0142 go rozpozna\u0107 jako pakiet.</p> <p>Pakiety mog\u0105 by\u0107 zagnie\u017cd\u017cane w innych pakietach, tworz\u0105c struktur\u0119 drzewiast\u0105. Przyk\u0142adowa struktura pakietu mog\u0142aby wygl\u0105da\u0107 tak:</p> <pre><code>nasz-projekt/\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 zajecia01/\n\u2502   \u2502      \u251c\u2500\u2500 __init__.py\n\u2502   \u2502      \u251c\u2500\u2500 dodawanie.py\n\u2502   \u2502      \u251c\u2500\u2500 odejmowanie.py\n\u2502   \u2502      \u2514\u2500\u2500 dzielenie.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2502\n\u251c\u2500\u2500 docs/\n\u2502\n\u2514\u2500\u2500 tests/\n</code></pre>"},{"location":"zaj3/pakiety/#pliki-__init__py","title":"Pliki <code>__init__.py</code>","text":"<p>Jak widzimy w przyk\u0142adowej strukturze powy\u017cej, ka\u017cdy katalog, kt\u00f3ry ma by\u0107 rozpoznawany jako cz\u0119\u015b\u0107 pakietu, posiada ten plik. Pocz\u0105tkowo, w starszych wersjach Pythona, ten plik by\u0142 obowi\u0105zkowy; obecnie w Pythonie 3.x nadal jest u\u017cywany, ale jego obecno\u015b\u0107 nie jest wymagana do rozpoznania katalogu jako pakietu. Jednak <code>__init__.py</code> nadal ma wa\u017cne funkcje:</p> <ul> <li>Inicjalizacja pakietu \u2013 Plik <code>__init__.py</code> jest uruchamiany przy pierwszym importowaniu pakietu, wi\u0119c mo\u017cna w nim umie\u015bci\u0107 kod, kt\u00f3ry zostanie wykonany na pocz\u0105tku.</li> <li>Kontrolowanie import\u00f3w \u2013 Mo\u017cemy zdefiniowa\u0107 list\u0119 <code>__all__</code> w <code>__init__.py</code>, aby kontrolowa\u0107, kt\u00f3re modu\u0142y zostan\u0105 zaimportowane, gdy u\u017cyjemy <code>from pakiet import *</code>.</li> </ul> <p>Przyk\u0142adowy plik <code>__init__.py</code> znajduj\u0105cy si\u0119 w <code>zaj\u0119cia01</code>:</p> <pre><code>__all__ = [\"dodawanie\", \"odejmowanie\"]\n</code></pre> <p>Dzi\u0119ki temu przy <code>from zajecia01 import *</code> zostan\u0105 zaimportowane tylko modu\u0142y <code>dodawanie</code> i <code>odejmowanie</code>, podczas gdy <code>dzielenie</code> zostanie pomini\u0119te.</p>"},{"location":"zaj3/pakiety/#importowanie-moduow","title":"Importowanie modu\u0142\u00f3w","text":"<p>Mamy 2 g\u0142\u00f3wne typy importu:</p> <ul> <li>Import bezwzgl\u0119dny \u2013 polega na podaniu pe\u0142nej \u015bcie\u017cki do modu\u0142u lub pakietu, np. <code>import kalkulator.dodawanie</code>.</li> <li>Import wzgl\u0119dny \u2013 u\u017cywany jest wewn\u0105trz pakiet\u00f3w i bazuje na kropkach wiod\u0105cych:<ul> <li>Jedna kropka <code>.</code> oznacza bie\u017c\u0105cy pakiet.</li> <li>Dwie kropki <code>..</code> oznaczaj\u0105 pakiet nadrz\u0119dny.</li> </ul> </li> </ul> Warning <p>Import wzgl\u0119dny dzia\u0142a tylko wtedy, gdy jeste\u015bmy w kontek\u015bcie pakietu, np. podczas importowania modu\u0142\u00f3w wewn\u0105trz innego modu\u0142u tego samego pakietu.</p> Przyk\u0142ad - importowanie bezwzgl\u0119dne <pre><code>from zajecia01 import dodawanie, odejmowanie\n\nprint(dodawanie.dodaj(5, 3))  # U\u017cycie funkcji dodaj z modu\u0142u dodawanie\nprint(odejmowanie.odejmij(5, 3))  # U\u017cycie funkcji odejmij z modu\u0142u odejmowanie\n</code></pre> Przyk\u0142ad - importowanie wzgl\u0119dne (wewn\u0105trz pakietu) <p>B\u0119d\u0105c w pliku <code>zajecia01/mnozenie.py</code></p> <pre><code>from .dodawanie import dodaj  # Import z bie\u017c\u0105cego pakietu\n\ndef mnoz(a, b):\n    wynik = 0\n    for _ in range(b):\n        wynik = dodaj(wynik, a)  # U\u017cycie funkcji dodaj\n    return wynik\n</code></pre>"},{"location":"zaj3/pakiety/#zadania","title":"Zadania","text":"<ol> <li>Wykorzystuj\u0105c aktualn\u0105 struktur\u0119 repozytorium, stw\u00f3rz w g\u0142\u00f3wnym katalogu plik <code>run.py</code>, zaimportuj do niego wybrane funkcje / klasy i wywo\u0142aj przyk\u0142adowy kod z ich u\u017cyciem.</li> </ol> <p>Tip</p> <p>Nie zapomnij doda\u0107 plik\u00f3w <code>__init__.py</code> wewn\u0105trz pakiet\u00f3w, a tak\u017ce list <code>__all__</code> w tych plikach.</p>"},{"location":"zaj3/zasiegi/","title":"Zasi\u0119gi","text":"<p>Zasi\u0119g (ang. scope) okre\u015bla, gdzie dana zmienna lub funkcja jest widoczna i dost\u0119pna. Zasady te pomagaj\u0105 w organizacji kodu oraz unikni\u0119ciu b\u0142\u0119d\u00f3w wynikaj\u0105cych z konflikt\u00f3w nazw.</p> <p>G\u0142\u00f3wne zasady zarz\u0105dzania zasi\u0119giem opieraj\u0105 si\u0119 na regule LEGB oraz specjalnych instrukcjach <code>global</code> i <code>nonlocal</code>.</p>"},{"location":"zaj3/zasiegi/#przypisane-nazwy-sa-lokalne","title":"Przypisane nazwy s\u0105 lokalne","text":"<p>Kiedy przypisujemy warto\u015b\u0107 zmiennej w funkcji, staje si\u0119 ona lokalna dla tej funkcji. Oznacza to, \u017ce poza t\u0105 funkcj\u0105 nie b\u0119dzie widoczna.</p> <pre><code>def funkcja():\n    x = 10  # Zmienna lokalna, widoczna tylko w funkcji\n    print(x)\n\nfunkcja()  # Wy\u015bwietli 10\n\n# Natomiast taka operacja nie ma ju\u017c sensu, zmienna x\n# istnieje tylko wewnatrz funkcji\nprint(x)\n</code></pre>"},{"location":"zaj3/zasiegi/#regua-legb","title":"Regu\u0142a LEGB","text":"<p>Regu\u0142a ta okre\u015bla w jakiej kolejno\u015bci Python wyszukuje zmienne i funkcje, gdy napotka na nie w kodzie. Jest to wa\u017cne, poniewa\u017c pozwala programi\u015bcie zrozumie\u0107, sk\u0105d Python pobiera warto\u015b\u0107 zmiennej, zw\u0142aszcza gdy zmienne o tej samej nazwie wyst\u0119puj\u0105 w r\u00f3\u017cnych zakresach (np. wewn\u0105trz funkcji, w funkcjach zagnie\u017cd\u017conych, w skrypcie globalnym).</p> <p>LEGB to akronim od 4 typ\u00f3w zasi\u0119g\u00f3w, przez kt\u00f3re Python przechodzi w nast\u0119puj\u0105cej kolejno\u015bci:</p> <ol> <li>Local - zmienne zadeklarowane w bie\u017c\u0105cej funkcji lub wewn\u0119trznej funkcji (najbardziej wewn\u0119trzny zasi\u0119g).</li> <li>Enclosing - zmienne zadeklarowane w zewn\u0119trznej funkcji, je\u015bli funkcje s\u0105 zagnie\u017cd\u017cone.</li> <li>Global - zmienne deklarowane w skrypcie g\u0142\u00f3wnym, poza funkcjami, czyli na poziomie modu\u0142u.</li> <li>Built-in - zmienne i funkcje wbudowane, dost\u0119pne globalnie (np. print, len).</li> </ol> <pre><code># W danym skrypcie / w danym module x jest\n# zmienn\u0105 globaln\u0105\nx = \"global\"\n\ndef zewnetrzna():\n    x = \"enclosing\"\n\n    # Tak, funkcje mog\u0105 by\u0107 zagnie\u017cd\u017cone\n    def wewnetrzna():\n        x = \"local\"\n        print(x)  # Wydrukuje \"local\", bo najpierw przeszukuje lokalne zmienne\n    wewnetrzna()\n    print(x)  # Wydrukuje \"enclosing\"\n\nzewnetrzna()\nprint(x)  # Wydrukuje \"global\"\n</code></pre>"},{"location":"zaj3/zasiegi/#instrukcje-global-i-nonlocal","title":"Instrukcje <code>global</code> i <code>nonlocal</code>","text":"<ul> <li><code>global</code> - pozwala zadeklarowa\u0107 zmienn\u0105 globaln\u0105 w funkcji, zmieniaj\u0105c jej warto\u015b\u0107 globalnie.</li> <li><code>nonlocal</code> - umo\u017cliwia przypisanie warto\u015bci do zmiennej z otaczaj\u0105cego zakresu (nie globalnego), co przydaje si\u0119 w funkcjach zagnie\u017cd\u017conych.</li> </ul> <p>Przyk\u0142ad u\u017cycia <code>global</code>: <pre><code>y = 5\n\ndef zmien_globalne():\n    global y\n    y = 10\n\nzmien_globalne()\nprint(y)  # Wydrukuje 10\n# Gdyby nie zastosowanie instrukcji global to y by\u0142oby\n# dalej r\u00f3wne 5, bo r\u00f3wne 10 by\u0142oby jedynie lokalnie w funkcji\n</code></pre></p> <p>Przyk\u0142ad u\u017cycia <code>nonlocal</code>: <pre><code>def zewnetrzna():\n    x = \"original\"\n\n    def wewnetrzna():\n        nonlocal x\n        x = \"modified\"\n\n    wewnetrzna()\n    print(x)  # Wydrukuje \"modified\"\n    # Pomimo tego, \u017ce x zosta\u0142o zmodyfikowane jedynie\n    # wewn\u0105trz funkcji zagnie\u017cd\u017conej\n\nzewnetrzna()\n</code></pre></p>"},{"location":"zaj3/zasiegi/#funkcje-zagniezdzone-funkcje-fabrykujace","title":"Funkcje zagnie\u017cd\u017cone, funkcje fabrykuj\u0105ce","text":"<p>Funkcje zagnie\u017cd\u017cone (ang. nested functions) to po prostu funkcje zdefiniowanie wewn\u0105trz innych funkcji. Mog\u0105 by\u0107 tak\u017ce wywo\u0142ywane wewn\u0105trz, ale nie tylko, bo mog\u0105 by\u0107 r\u00f3wnie\u017c zwracane, u\u017cywane jako argument czy by\u0107 prywatnymi funkcjami pomocniczymi.</p> Przyk\u0142ady dla funkcji zagnie\u017cd\u017conych <p>Wywo\u0142anie funkcji wewn\u0105trz:</p> <pre><code>def zewnetrzna(x):\n    def wewnetrzna(y):\n        return x + y\n    # Funkcja wewnetrzna jest dost\u0119pna tylko w zewnetrzna\n    return wewnetrzna(x)\n\nprint(zewnetrzna(5))  # Wydrukuje 10\nprint(wewnetrzna(3))  # Spowoduje b\u0142\u0105d, bo wewnetrzna nie jest dost\u0119pna poza zewnetrzna\n</code></pre> <p>U\u017cycie funkcji zagnie\u017cd\u017conej jako funkcji fabrykuj\u0105cej:</p> <pre><code>def funkcja_fabrykujaca(wiadomosc):\n    def funkcja_zagniezdzona():\n        return f\"Twoja wiadomo\u015b\u0107 to: {wiadomosc}\"\n    return funkcja_zagniezdzona\n\n# Tworzymy now\u0105 funkcj\u0119, kt\u00f3ra pami\u0119ta \"wiadomosc\"\nnowa_funkcja = funkcja_fabrykujaca(\"Witaj, \u015bwiecie!\")\nprint(nowa_funkcja())  # Wydrukuje \"Twoja wiadomo\u015b\u0107 to: Witaj, \u015bwiecie!\"\n</code></pre> <p>Przekazanie funkcji zagnie\u017cd\u017conej jako argument:</p> <pre><code>def obliczenia(operator):\n    def dodaj(x, y):\n        return x + y\n\n    def mnoz(x, y):\n        return x * y\n\n    # Zwracamy funkcj\u0119 zagnie\u017cd\u017con\u0105 w zale\u017cno\u015bci od operatora\n    if operator == \"dodaj\":\n        return dodaj\n    elif operator == \"mnoz\":\n        return mnoz\n    else:\n        raise ValueError(\"Nieznany operator\")\n\n# Teraz mamy funkcj\u0119 dodaj i mnoz dost\u0119pn\u0105 spoza obliczenia\nwybrana_funkcja = obliczenia(\"dodaj\")\nprint(wybrana_funkcja(2, 3))  # Wydrukuje 5\n\nwybrana_funkcja = obliczenia(\"mnoz\")\nprint(wybrana_funkcja(2, 3))  # Wydrukuje 6\n</code></pre> <p>Tworzenie prywatnych funkcji pomocniczych:</p> <pre><code>def przetwarzaj_dane(lista):\n    def filtruj(x):\n        return x % 2 == 0\n\n    def kwadrat(x):\n        return x ** 2\n\n    przefiltrowane = filter(filtruj, lista)\n    return [kwadrat(x) for x in przefiltrowane]\n\nprint(przetwarzaj_dane([1, 2, 3, 4, 5, 6]))  # Wydrukuje [4, 16, 36]\n</code></pre> <p>Funkcje fabrykuj\u0105ce (ang. factory functions) s\u0105 wi\u0119c jednym z typ\u00f3w funkcji zagnie\u017cd\u017conych, gdzie zwracana jest funkcja wewn\u0119trzna. Funkcje fabrykuj\u0105ce wykorzystuj\u0105 zamkni\u0119cia, co oznacza, \u017ce funkcje, kt\u00f3re zwracaj\u0105, pami\u0119taj\u0105 kontekst, w kt\u00f3rym zosta\u0142y stworzone (np. warto\u015bci zmiennych z zakresu otaczaj\u0105cego). To pozwala im zachowa\u0107 stan, co czyni je bardzo przydatnymi do tworzenia funkcji z predefiniowanymi ustawieniami lub konfiguracjami.</p> Przyk\u0142ady dla funkcji zagnie\u017cd\u017conych <p>Predefiniowanie parametr\u00f3w:</p> <pre><code>def mnoznik(factor):\n    def pomnoz(x):\n        return x * factor\n    return pomnoz  # Zwracamy now\u0105 funkcj\u0119\n\n# Tworzymy now\u0105 funkcj\u0119 z zapami\u0119tanym \"factor\"\npomnoz_2 = mnoznik(2)\npomnoz_3 = mnoznik(3)\n\nprint(pomnoz_2(5))  # Wydrukuje 10 (5 * 2)\nprint(pomnoz_3(5))  # Wydrukuje 15 (5 * 3)\n</code></pre> <p>Liczniki:</p> <pre><code>def licznik():\n    count = 0\n\n    def zwieksz():\n        nonlocal count\n        count += 1\n        return count\n\n    return zwieksz\n\nlicznik1 = licznik()\nlicznik2 = licznik()\n\nprint(licznik1())  # Wydrukuje 1\nprint(licznik1())  # Wydrukuje 2\nprint(licznik2())  # Wydrukuje 1 (nowy licznik)\n</code></pre> <p>Konfiguracje w ramach wzorca fabrykuj\u0105cego:</p> <pre><code>def formatuj_text(style):\n    def formatuj(wiadomosc):\n        if style == \"uppercase\":\n            return wiadomosc.upper()\n        elif style == \"lowercase\":\n            return wiadomosc.lower()\n        elif style == \"capitalize\":\n            return wiadomosc.capitalize()\n        else:\n            return wiadomosc\n    return formatuj\n\nuppercase_formatter = formatuj_text(\"uppercase\")\nlowercase_formatter = formatuj_text(\"lowercase\")\n\nprint(uppercase_formatter(\"hello world\"))  # Wydrukuje \"HELLO WORLD\"\nprint(lowercase_formatter(\"HELLO WORLD\"))  # Wydrukuje \"hello world\"\n</code></pre> <p>Walidatory: <pre><code>def walidator_dlugosci(min_dlugosc, max_dlugosc):\n    def waliduj(text):\n        return min_dlugosc &lt;= len(text) &lt;= max_dlugosc\n    return waliduj\n\nmaly_tekst = walidator_dlugosci(1, 5)\nduzy_tekst = walidator_dlugosci(5, 10)\n\nprint(maly_tekst(\"Hi\"))       # Wydrukuje True\nprint(maly_tekst(\"HelloWorld\"))  # Wydrukuje False\nprint(duzy_tekst(\"Python\"))    # Wydrukuje True\n</code></pre></p> <p>Funkcje z\u0142o\u017conych oblicze\u0144:</p> <pre><code>def procent_calculator(procent):\n    def oblicz(calkowita_kwota):\n        return calkowita_kwota * (procent / 100)\n    return oblicz\n\npodatek_vat = procent_calculator(23)\nzysk_kapitalowy = procent_calculator(19)\n\nprint(podatek_vat(1000))  # Wydrukuje 230.0\nprint(zysk_kapitalowy(1000))  # Wydrukuje 190.0\n</code></pre> <p>Z\u0142o\u017cone filtry i sortowania:</p> <pre><code>def filtruj_po_min_wartosci(min_wartosc):\n    def filtruj(lista):\n        return [x for x in lista if x &gt;= min_wartosc]\n    return filtruj\n\nfiltruj_od_10 = filtruj_po_min_wartosci(10)\n\nprint(filtruj_od_10([5, 10, 15, 20]))  # Wydrukuje [10, 15, 20]\n</code></pre>"},{"location":"zaj3/zasiegi/#zadania","title":"Zadania","text":"<ol> <li>Napisz funkcj\u0119 fabrykuj\u0105c\u0105 <code>stworz_funkcje_potegujaca(wykladnik)</code>, kt\u00f3ra przyjmuje jeden argument: wyk\u0142adnik pot\u0119gi. Zwracana przez ni\u0105 funkcja zagnie\u017cd\u017cona <code>poteguj(podstawa)</code> powinna r\u00f3wnie\u017c przyjmowa\u0107 jeden argument \u2013 podstaw\u0119 pot\u0119gi \u2013 i zwraca\u0107 wynik podniesienia tej podstawy do pot\u0119gi okre\u015blonej przez wyk\u0142adnik przekazany do funkcji zewn\u0119trznej.</li> </ol> <p>Tip</p> <p>Wywo\u0142anie takiej funkcji i sprawdzenie powinno wygl\u0105da\u0107 nast\u0119puj\u0105co: </p> <pre><code>potega_2 = stworz_funkcje_potegujaca(2)`  # Tworzy funkcj\u0119 pot\u0119guj\u0105c\u0105 do kwadratu\nprint(potega_2(4))  # Wynik: 16\n</code></pre>"},{"location":"zaj3/zasiegi/#zachowanie-stanu","title":"Zachowanie stanu","text":"<p>Jest istotnym elementem programowania, szczeg\u00f3lnie w przypadku potrzeby utrzymania danych pomi\u0119dzy kolejnymi wywo\u0142aniami funkcji lub fragmentami kodu. </p> <p>Jest to te\u017c dobry przypadek u\u017cycia dla zagadnie\u0144 poznanych na dzisiejszych zaj\u0119ciach.</p> <p>Za przyk\u0142ad pos\u0142u\u017cy nam akumulator, kt\u00f3ry zbiera\u0107 b\u0119dzie liczby dodawane w kolejnych wywo\u0142aniach funkcji. Po ka\u017cdym dodaniu chcemy mie\u0107 mo\u017cliwo\u015b\u0107 pobrania aktualnej sumy. Poni\u017cej ro\u017cne przyk\u0142ady implementacyjne:</p> U\u017cycie zmiennej <code>nonlocal</code> <pre><code>def akumulator_nonlocal():\n    suma = 0\n\n    def dodaj_wartosc(wartosc):\n        nonlocal suma\n        suma += wartosc\n        return suma\n\n    return dodaj_wartosc\n\n# Przyk\u0142ad u\u017cycia\nakum = akumulator_nonlocal()\nprint(akum(5))  # Wydrukuje 5\nprint(akum(10))  # Wydrukuje 15\n</code></pre> U\u017cycie zmiennej <code>global</code> <p>Zmienne <code>global</code> pozwalaj\u0105 na dost\u0119p i modyfikacj\u0119 zmiennych globalnych wewn\u0105trz funkcji. To podej\u015bcie jest rzadziej stosowane, gdy\u017c zmienne globalne s\u0105 widoczne w ca\u0142ym module, co mo\u017ce prowadzi\u0107 do b\u0142\u0119d\u00f3w, ale w niekt\u00f3rych sytuacjach mo\u017ce si\u0119 przyda\u0107.    </p> <pre><code>suma_global = 0\n\ndef dodaj_do_akumulatora(wartosc):\n    global suma_global\n    suma_global += wartosc\n    return suma_global\n\n# Przyk\u0142ad u\u017cycia\nprint(dodaj_do_akumulatora(5))   # Wydrukuje 5\nprint(dodaj_do_akumulatora(10))  # Wydrukuje 15\n</code></pre> U\u017cycie klasy <p>Co prawda klasy b\u0119d\u0105 dopiero na przysz\u0142ych zaj\u0119ciach, ale s\u0105 jednym z najcz\u0119stszych sposob\u00f3w zarz\u0105dzania stanem. Instancje klas pozwalaj\u0105 na \u0142atwe tworzenie i przechowywanie danych w atrybutach. <pre><code>class Akumulator:\n    def __init__(self):\n        self.suma = 0\n\n    def dodaj(self, wartosc):\n        self.suma += wartosc\n        return self.suma\n\n# Przyk\u0142ad u\u017cycia\nakum = Akumulator()\nprint(akum.dodaj(5))   # Wydrukuje 5\nprint(akum.dodaj(10))  # Wydrukuje 15\n</code></pre></p> U\u017cycie atrybutu funkcji <pre><code>def akumulator_funkcyjny(wartosc):\n    akumulator_funkcyjny.suma += wartosc\n    return akumulator_funkcyjny.suma\n\n# Inicjalizacja atrybutu funkcji\nakumulator_funkcyjny.suma = 0\n\n# Przyk\u0142ad u\u017cycia\nprint(akumulator_funkcyjny(5))   # Wydrukuje 5\nprint(akumulator_funkcyjny(10))  # Wydrukuje 15\n</code></pre>"},{"location":"zaj3/zasiegi/#zadania_1","title":"Zadania","text":"<ol> <li> <p>Napisz funkcj\u0119 <code>licznik()</code>, kt\u00f3ra za ka\u017cdym razem, gdy jest wywo\u0142ywana, zwi\u0119ksza swoje wewn\u0119trzne liczenie o jeden (licznik stanu). Zaimplementuj cztery wersje tej funkcji, wykorzystuj\u0105c:</p> <ul> <li> <p>Zmienn\u0105 <code>nonlocal</code> w zagnie\u017cd\u017conej funkcji</p> </li> <li> <p>Zmienn\u0105 <code>global</code>.</p> </li> <li> <p>Klas\u0119 z atrybutem instancji - wskaz\u00f3wka: zaimplementowanie w klasie funkcji <code>__init__</code> oraz <code>__call__</code> </p> </li> <li> <p>Atrybut funkcji - funkcja, jak ka\u017cdy inny obiekt, mo\u017ce mie\u0107 swoje atrybuty</p> </li> </ul> </li> </ol>"},{"location":"zaj4/obiektowe/","title":"Programowanie obiektowe","text":"<p>Jest to paradygmat programowania, kt\u00f3ry opiera si\u0119 na tworzeniu obiekt\u00f3w \u2013 element\u00f3w, kt\u00f3re \u0142\u0105cz\u0105 dane i logik\u0119 w sp\u00f3jn\u0105 ca\u0142o\u015b\u0107. Ka\u017cdy obiekt reprezentuje pewien byt (np. samoch\u00f3d, u\u017cytkownik, dokument) i posiada w\u0142asne w\u0142a\u015bciwo\u015bci oraz zachowania.</p>"},{"location":"zaj4/obiektowe/#klasa","title":"Klasa","text":"<p>Szablon lub przepis, kt\u00f3ry definiuje struktur\u0119 i zachowanie jej instancji. Klasa okre\u015bla, jakie atrybuty (cechy) i metody (dzia\u0142ania) b\u0119d\u0105 posiada\u0142y instancje nale\u017c\u0105ce do tej klasy. Przyk\u0142adowo, klasa <code>Samochod</code> mo\u017ce zawiera\u0107 takie atrybuty, jak <code>marka</code>, <code>model</code>, <code>rok</code>, a tak\u017ce metody jak <code>przyspiesz()</code> czy <code>hamuj()</code>.</p> <pre><code>class Samochod:\n    def __init__(self, marka, model, rok):\n        self.marka = marka\n        self.model = model\n        self.rok = rok\n</code></pre> <p>Gdy m\u00f3wimy o obiektach klasy, mamy na my\u015bli struktur\u0119 (sam\u0105 definicj\u0119), z kt\u00f3rych mo\u017cna tworzy\u0107 instancje.</p>"},{"location":"zaj4/obiektowe/#instancja","title":"Instancja","text":"<p>Konkretny egzemplarz klasy, stworzony na podstawie jej definicji. Instancje posiadaj\u0105 swoje w\u0142asne warto\u015bci atrybut\u00f3w, cho\u0107 wszystkie nale\u017c\u0105 do tej samej klasy.</p> <pre><code>moj_samochod = Samochod('Toyota', 'Corolla', 2020)\n</code></pre> <p>Obiekty instancji (lub po prostu instancje) to konkretne przyk\u0142ady danej klasy, kt\u00f3re istniej\u0105 w programie i posiadaj\u0105 w\u0142asne dane.</p>"},{"location":"zaj4/obiektowe/#atrybuty","title":"Atrybuty","text":"<p>Przechowuj\u0105 stan obiektu. Ka\u017cdy atrybut jest cz\u0119\u015bci\u0105 obiektu i przechowuje informacje specyficzne dla danej instancji klasy.</p> <p>Atrybuty mo\u017cna definiowa\u0107 w konstruktorze klasy (metodzie <code>__init__</code>), co umo\u017cliwia ka\u017cdej instancji posiadanie indywidualnych warto\u015bci.</p> <p>W naszym przyk\u0142adzie <code>marka</code>, <code>model</code> i <code>rok</code> to atrybuty.</p> <pre><code># Ka\u017cda instancja posiada swoje w\u0142asne (inne lub nie; unikatowe lub nie) warto\u015bci atrybut\u00f3w\nmoj_samochod = Samochod('Toyota', 'Corolla', 2020)\nkogos_innego_samochod = Samochod('Ford', 'Focus', 2018)\n</code></pre> <pre><code># Dost\u0119p do warto\u015bci atrybut\u00f3w danej instancji klasy\nprint(moj_samochod.model)\n</code></pre>"},{"location":"zaj4/obiektowe/#metody","title":"Metody","text":"<p>Funkcje zdefiniowane wewn\u0105trz klasy, kt\u00f3re operuj\u0105 na instancjach tej klasy i mog\u0105 zmienia\u0107 ich stan.</p> <p>Zwykle w pierwszym argumencie metody umieszcza si\u0119 <code>self</code>, co pozwala na dost\u0119p do atrybut\u00f3w i innych metod obiektu.</p> <pre><code># Rozszerzenie klasy Samochod o metod\u0119 przyspiesz\nclass Samochod:\n    def __init__(self, marka, model, rok):\n        self.marka = marka\n        self.model = model\n        self.rok = rok\n\n    def przyspiesz(self, wartosc: int = 10):\n        print(f\"{self.marka} {self.model} przyspiesza o {wartosc}!\")\n\nmoj_samochod.przyspiesz(20)  # wywo\u0142anie metody\n# Zwraca formatted string: Toyota Corolla przyspiesza o 20!\n</code></pre>"},{"location":"zaj4/obiektowe/#po-co-programowac-obiektowo","title":"Po co programowa\u0107 obiektowo?","text":"<p>Programowanie obiektowe (OOP - ang. object-oriented programming) jest cz\u0119sto stosowane w celu uporz\u0105dkowania kodu i u\u0142atwienia zarz\u0105dzania z\u0142o\u017conymi projektami.</p> <p>Zalety:</p> <ul> <li>Modularno\u015b\u0107 i ponowne wykorzystanie kodu: OOP sprzyja tworzeniu modu\u0142owego kodu, gdzie klasy mo\u017cna wykorzysta\u0107 wielokrotnie w r\u00f3\u017cnych cz\u0119\u015bciach programu, co zmniejsza ilo\u015b\u0107 powtarzanego kodu i u\u0142atwia modyfikacje.</li> <li>Hermetyzacja: Dzi\u0119ki niej mo\u017cna ukry\u0107 szczeg\u00f3\u0142y implementacyjne klasy przed u\u017cytkownikami, kt\u00f3rzy korzystaj\u0105 tylko z interfejsu, co zwi\u0119ksza bezpiecze\u0144stwo kodu i minimalizuje ryzyko przypadkowego naruszenia wewn\u0119trznego stanu obiektu.</li> <li>Dziedziczenie: Pozwala na tworzenie nowych klas na bazie istniej\u0105cych, co sprzyja hierarchii i u\u0142atwia rozszerzanie funkcjonalno\u015bci, redukuj\u0105c potrzeb\u0119 pisania kodu od podstaw.</li> <li>Polimorfizm: Dzi\u0119ki polimorfizmowi r\u00f3\u017cne klasy mog\u0105 reagowa\u0107 na te same polecenia w odmienny spos\u00f3b, co upraszcza zarz\u0105dzanie r\u00f3\u017cnymi obiektami i zwi\u0119ksza elastyczno\u015b\u0107 kodu.</li> <li>Lepsze zarz\u0105dzanie z\u0142o\u017conymi systemami: OOP umo\u017cliwia tworzenie struktur, kt\u00f3re \u0142atwiej utrzyma\u0107 w du\u017cych projektach, co jest szczeg\u00f3lnie przydatne w z\u0142o\u017conych aplikacjach.</li> <li>\u0141atwo\u015b\u0107 utrzymania i modyfikacji: Kod obiektowy jest cz\u0119sto \u0142atwiejszy do utrzymania, poniewa\u017c klasy i obiekty mo\u017cna modyfikowa\u0107 niezale\u017cnie, bez wp\u0142ywu na inne cz\u0119\u015bci systemu.</li> </ul> <p>Wady:</p> <ul> <li>Wymaga poprzedzaj\u0105cego planowania koncepcyjnego: Tworzenie kodu obiektowego wymaga wcze\u015bniejszego przemy\u015blenia architektury, co mo\u017ce by\u0107 czasoch\u0142onne, zw\u0142aszcza w mniejszych projektach.</li> <li>Z\u0142o\u017cono\u015b\u0107: Programowanie obiektowe mo\u017ce wydawa\u0107 si\u0119 skomplikowane, szczeg\u00f3lnie dla pocz\u0105tkuj\u0105cych, przez co trudniej nauczy\u0107 si\u0119 i wdro\u017cy\u0107 OOP w prostych aplikacjach.</li> <li>Ukrywanie stanu: Chocia\u017c hermetyzacja jest zalet\u0105, czasem mo\u017ce by\u0107 wad\u0105 \u2013 nie zawsze mamy pe\u0142ny dost\u0119p do informacji o obiekcie, co mo\u017ce ogranicza\u0107 elastyczno\u015b\u0107 kodu.</li> <li>Wydajno\u015b\u0107: Obiektowy kod jest zazwyczaj ci\u0119\u017cszy i wolniejszy ni\u017c podej\u015bcie proceduralne, co mo\u017ce mie\u0107 znaczenie w aplikacjach wymagaj\u0105cych wysokiej wydajno\u015bci.</li> <li>Nadmierna abstrakcja: Nadmierne stosowanie obiekt\u00f3w i klas mo\u017ce prowadzi\u0107 do abstrakcji, kt\u00f3re nie zawsze s\u0105 intuicyjne i mog\u0105 utrudnia\u0107 zrozumienie kodu.</li> <li>Nie zawsze najlepsze dopasowanie do przypadk\u00f3w u\u017cycia: W niekt\u00f3rych przypadkach, zw\u0142aszcza przy przetwarzaniu danych, podej\u015bcie proceduralne jest bardziej efektywne ni\u017c OOP, co sprawia, \u017ce stosowanie klas i obiekt\u00f3w mo\u017ce by\u0107 zb\u0119dne.</li> </ul>"},{"location":"zaj4/obiektowe/#dziedziczenie","title":"Dziedziczenie","text":"<p>Kluczowa cecha programowania obiektowego, pozwala na tworzenie nowych klas na bazie istniej\u0105cych. Umo\u017cliwia to wykorzystanie ju\u017c zdefiniowanych atrybut\u00f3w i metod w nowej klasie, co sprzyja oszcz\u0119dno\u015bci kodu i u\u0142atwia jego zarz\u0105dzanie.</p> Uwaga <p>Zwr\u00f3\u0107 uwag\u0119 w poni\u017cszym przyk\u0142adzie jak wygl\u0105da wywo\u0142ywanie konstruktor\u00f3w klas nadrz\u0119dnych.</p> <pre><code>class Pojazd:  # Klasa bazowa\n    def __init__(self, marka):\n        self.marka = marka\n\n    def uruchom(self):\n        print(f\"{self.marka} jest uruchamiany.\")\n\nclass Samochod(Pojazd):  # Klasa pochodna\n    def __init__(self, marka, model):\n        super().__init__(marka)  # Wywo\u0142anie konstruktora klasy bazowej\n        self.model = model\n</code></pre>"},{"location":"zaj4/obiektowe/#wyszukiwanie-dziedziczenia","title":"Wyszukiwanie dziedziczenia","text":"<p>Gdy obiekt wywo\u0142uje metod\u0119 lub uzyskuje dost\u0119p do atrybutu, Python rozpoczyna proces wyszukiwania tego elementu zgodnie z tzw. MRO (Method Resolution Order) \u2013 to algorytm wyszukiwania dziedziczenia: 1. Najpierw sprawdzana jest klasa, do kt\u00f3rej nale\u017cy dany obiekt (czyli klasa pochodna). 2. Nast\u0119pnie sprawdzane s\u0105 klasy bazowe (superklasy) w kolejno\u015bci od najbli\u017cszej do najdalszej. 3. Je\u015bli Python znajdzie odpowiedni element w pierwszej napotkanej klasie, ko\u0144czy poszukiwanie.</p> <p>Klasy mog\u0105 tak\u017ce dziedziczy\u0107 po wi\u0119cej ni\u017c jednej klasie - nazywamy to dziedziczeniem wielokrotnym. W takim wypadku wyszukiwanie z pkt. 2 odbywa si\u0119 od najbli\u017cszej klasy bazowej (wymieniona jako pierwsza przy definiowaniu dziedziczenia) do najdalszej.</p> <pre><code>class Pojazd:\n    def uruchom(self):\n        print(\"Pojazd jest uruchamiany.\")\n\nclass Silnik:\n    def uruchom(self):\n        print(\"Silnik jest uruchamiany.\")\n\nclass Samochod(Pojazd, Silnik):\n    pass\n\nmoj_samochod = Samochod()\nmoj_samochod.uruchom()\n\n## Zwraca: Pojazd jest uruchamiany.\n</code></pre> <p>Aby sprawdzi\u0107 kolejno\u015b\u0107 MRO, mo\u017cna u\u017cy\u0107 metody <code>.__mro__</code> lub funkcji <code>help()</code>: <pre><code>print(Samochod.__mro__)\n</code></pre></p> <p>Je\u015bli metoda lub atrybut nie istnieje ani w klasie pochodnej, ani w \u017cadnej z klas bazowych, Python zg\u0142asza b\u0142\u0105d, np. <code>AttributeError</code>.</p>"},{"location":"zaj4/obiektowe/#nadpisywanie-overriding","title":"Nadpisywanie (overriding)","text":"<p>Proces, w kt\u00f3rym klasa pochodna definiuje w\u0142asn\u0105 wersj\u0119 metody o tej samej nazwie, co metoda w klasie bazowej. Dzi\u0119ki temu klasa pochodna mo\u017ce zmieni\u0107 lub rozszerzy\u0107 dzia\u0142anie odziedziczonej metody, dostosowuj\u0105c j\u0105 do w\u0142asnych potrzeb.</p> Uwaga <p>Zwr\u00f3\u0107 uwag\u0119 w poni\u017cszym przyk\u0142adzie jak wygl\u0105da specjalizacja odziedziczonych metod.</p> <pre><code>class Pojazd:\n    def uruchom(self):\n        print(\"Pojazd jest uruchamiany.\")\n\nclass Samochod(Pojazd):\n    def uruchom(self):  # Nadpisywanie metody uruchom\n        print(\"Samoch\u00f3d jest uruchamiany szybciej!\")\n        super().uruchom()  # Wywo\u0142anie oryginalnej metody klasy bazowej\n\nmoj_samochod = Samochod()\nmoj_samochod.uruchom()\n</code></pre>"},{"location":"zaj4/obiektowe/#przeciazanie-operatorow","title":"Przeci\u0105\u017canie operator\u00f3w","text":"<p>Technika, kt\u00f3ra pozwala definiowa\u0107, jak klasy b\u0119d\u0105 odpowiada\u0107 na standardowe operacje, takie jak np. dodawanie, por\u00f3wnywanie czy wy\u015bwietlanie reprezentacji tekstowej.</p> <p>W Pythonie przeci\u0105\u017canie odbywa si\u0119 przez definiowanie w klasie specjalnych metod (tzw. dunder methods \u2013 od double underscore methods), kt\u00f3re zaczynaj\u0105 i ko\u0144cz\u0105 podw\u00f3jnym podkre\u015bleniem (np. <code>__init__</code>, <code>__add__</code> czy <code>__str__</code>).</p> <pre><code>class Wektor:\n    # Ta metoda odpowiada za inicjalizacj\u0119\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # Metoda przeci\u0105\u017caj\u0105ca operator +\n    # Definiuje dodawanie wiektora do wektora\n    def __add__(self, inny_wektor):\n        return Wektor(self.x + inny_wektor.x, self.y + inny_wektor.y)\n\n    # Metoda przeci\u0105\u017caj\u0105ca operator &lt;\n    def __lt__(self, inny_wektor):\n        return (self.x**2 + self.y**2) &lt; (inny_wektor.x**2 + inny_wektor.y**2)\n\n    # Definiuje tekstow\u0105 reprezentacj\u0119 obiektu\n    def __str__(self):\n        return f\"Wektor({self.x}, {self.y})\"\n\nwektor1 = Wektor(2, 3)\nwektor2 = Wektor(1, 1)\nsuma = wektor1 + wektor2\nprint(suma)\nprint(wektor1 &lt; wektor2)\n</code></pre> Rozszerzona lista metod do przeci\u0105\u017cania operator\u00f3w Metoda Przeci\u0105\u017ca Wywo\u0142ywana dla <code>__init__</code> Konstruktor Tworzenie obiektu - <code>x = Klasa(args)</code> <code>__del__</code> Destruktor Zwolnienie obiektu <code>x</code> <code>__add__</code> Operator <code>+</code> <code>x + y</code>, <code>x += y</code>, je\u015bli nie ma <code>__iadd__</code> <code>__or__</code> Operator <code>|</code> (OR poziomu bitowego) <code>x | y</code>, <code>x |= y</code>, je\u015bli nie ma <code>__ior__</code> <code>__repr__</code>, <code>__str__</code> Wy\u015bwietlanie, konwersje <code>print(x)</code>, <code>repr(x)</code>, <code>str(x)</code> <code>__call__</code> Wywo\u0142anie funkcji <code>x(*args, **kargs)</code> <code>__getattr__</code> Odczytanie atrybutu <code>x.niezdefiniowany_atrybuty</code> <code>__setattr__</code> Przypisanie atrybutu <code>x.atrybut = wartosc</code> <code>__delattr__</code> Usuwanie atrybutu <code>del x.atrybut</code> <code>__getattribute__</code> Przechwytywanie atrybutu <code>x.atrybut</code> <code>__getitem__</code> Indeksowanie, wycinanie, iteracje <code>x[klucz]</code>, <code>x[i:j]</code>, p\u0119tle <code>for</code> oraz inne iteracje, je\u015bli nie ma <code>__iter__</code> <code>__setitem__</code> Przypisanie indeksu i wycinka <code>x[klucz] = wartosc</code>, <code>x[i:j] = sekwencja</code> <code>__delitem__</code> Usuwanie indeksu i wycinka <code>del x[klucz]</code>, <code>del x[i:j]</code> <code>__len__</code> D\u0142ugo\u015b\u0107 <code>len(x)</code>, testy prawdziwo\u015bci, je\u015bli nie ma <code>__bool__</code> <code>__bool__</code> Testy logiczne <code>bool(x)</code>, testy prawdziwo\u015bci <code>__lt__</code>, <code>__gt__</code>, <code>__le__</code>, <code>__ge__</code>, <code>__eq__</code>, <code>__ne__</code> Por\u00f3wnania <code>x &lt; y</code>, <code>x &gt; y</code>, <code>x &lt;= y</code>, <code>x &gt;= y</code>, <code>x == y</code>, <code>x != y</code> <code>__radd__</code> Prawostronny operator <code>+</code> <code>nieinstancja + x</code> <code>__iadd__</code> Dodawanie w miejscu (rozszerzone) <code>x += y</code> <code>__iter__</code>, <code>__next__</code> Konteksty iteracyjne <code>i = iter(x)</code>, <code>next(i)</code>; p\u0119tle <code>for</code>, je\u015bli nie ma <code>__contains__</code>, testy <code>in</code>, wszystkie listy sk\u0142adanie, funkcje <code>map(f,x)</code> <code>__contains__</code> Test przynale\u017cno\u015bci <code>item in x</code> (dowolny iterator) <code>__index__</code> Warto\u015b\u0107 ca\u0142kowita <code>hex(x)</code>, <code>bin(x)</code>, <code>oct(x)</code>, <code>o[x]</code>, <code>o[x:]</code> <code>__enter__</code>, <code>__exit__</code> Mened\u017cer konktekstu <code>with obj as var:</code> <code>__get__</code>, <code>__set__</code>, <code>__delete__</code> Atrybuty deskryptor\u00f3w <code>x.attr</code>, <code>x.attr = value</code>, <code>del x.attr</code> <code>__new__</code> Tworzenie instancji Tworzenie instancji, przed <code>__init__</code>"},{"location":"zaj4/obiektowe/#tworzenie-klas-przykad","title":"Tworzenie klas - przyk\u0142ad","text":""},{"location":"zaj4/obiektowe/#zadanie","title":"Zadanie","text":"<p>Wejd\u017a do repozytorium, zapoznaj si\u0119 z gotowym kodem w pliku <code>run_zajecia04.py</code> oraz modu\u0142ami w folderze <code>src/zajecia04</code>.</p> <p>Zwr\u00f3\u0107 uwag\u0119 na:</p> <ul> <li>Tworzenie konstruktor\u00f3w - <code>__init__</code>,</li> <li>Dodawanie metod,</li> <li>Tekstow\u0105 reprezentacj\u0119 klas - <code>__str__</code> oraz <code>__repr__</code> (jak przyk\u0142ad przeci\u0105\u017cania operator\u00f3w),</li> <li>Dostosowywanie klas poprzez klasy podrz\u0119dne.</li> </ul>"},{"location":"zaj4/obiektowe/#narzedzia-introspekcji","title":"Narz\u0119dzia introspekcji","text":"<p>Introspekcja pozwala na dynamiczne badanie obiekt\u00f3w, ich struktur oraz cech w czasie dzia\u0142ania programu.</p>"},{"location":"zaj4/obiektowe/#__class__","title":"<code>__class__</code>","text":"<p>Atrybut ten pozwala na sprawdzenie klasy, do kt\u00f3rej nale\u017cy dany obiekt.</p> <pre><code>class Zwierze:\n    pass\n\nclass Pies(Zwierze):\n    pass\n\nreksio = Pies()\nprint(reksio.__class__)  # &lt;class '__main__.Pies'&gt;\nprint(reksio.__class__.__name__)  # Pies\n</code></pre>"},{"location":"zaj4/obiektowe/#__dict__","title":"<code>__dict__</code>","text":"<p>Atrybut ten to s\u0142ownik, kt\u00f3ry przechowuje wszystkie atrybuty instancji obiektu. Dzi\u0119ki dict mo\u017cna dynamicznie uzyska\u0107 dost\u0119p do atrybut\u00f3w obiektu, modyfikowa\u0107 je, dodawa\u0107 nowe lub iterowa\u0107 po nich.</p> <pre><code>class Samochod:\n    def __init__(self, marka, model, rok):\n        self.marka = marka\n        self.model = model\n        self.rok = rok\n\nmoj_samochod = Samochod(\"Toyota\", \"Corolla\", 2020)\nprint(moj_samochod.__dict__) # {'marka': 'Toyota', 'model': 'Corolla', 'rok': 2020}\n</code></pre>"},{"location":"zaj4/obiektowe/#abstrakcyjne-klasy-nadrzedne","title":"Abstrakcyjne klasy nadrz\u0119dne","text":"<p>S\u0105 to klasy s\u0142u\u017c\u0105ce jako szablony, kt\u00f3re definiuj\u0105 struktur\u0119 i wymuszone metody dla klas pochodnych, ale same nie mog\u0105 by\u0107 inicjalizowane. U\u017cywaj\u0105 dekoratora <code>@abstractmethod</code> do oznaczenia metod, kt\u00f3re musz\u0105 by\u0107 zaimplementowane w klasach pochodnych.</p> Korzy\u015bci wynikaj\u0105ce z wykorzystywania abstrakcyjnych klas nadrz\u0119dnych <ul> <li>Sp\u00f3jno\u015b\u0107 \u2013 wymusza implementacj\u0119 okre\u015blonych metod.</li> <li>Reu\u017cywalno\u015b\u0107 \u2013 pozwala dzieli\u0107 metody mi\u0119dzy klasami.</li> <li>Polimorfizm \u2013 umo\u017cliwia jednolite u\u017cywanie r\u00f3\u017cnych klas.</li> </ul> <pre><code>from abc import ABC, abstractmethod\n\nclass Zwierze(ABC):\n    # Ta metoda jest abstrakcyjna,\n    # wymagana jest jej implementacja w klasach pochodnych\n    @abstractmethod\n    def wydaj_dzwiek(self):\n        pass\n\nclass Pies(Zwierze):\n    def wydaj_dzwiek(self):\n        return \"Hau hau!\"\n\nclass Kot(Zwierze):\n    def wydaj_dzwiek(self):\n        return \"Miau miau!\"\n</code></pre>"},{"location":"zaj4/obiektowe/#atrybuty-pseudoprywatne","title":"Atrybuty pseudoprywatne","text":"<p>Atrybuty, kt\u00f3rych nazwy zaczynaj\u0105 si\u0119 od dw\u00f3ch podkre\u015blnik\u00f3w, np. <code>__nazwa</code>. Taka konwencja nazw powoduje, \u017ce Python stosuje name mangling \u2013 czyli zmienia nazw\u0119 atrybutu w taki spos\u00f3b, \u017ce jest trudniej dost\u0119pna z zewn\u0105trz klasy, ale nie jest ca\u0142kowicie prywatna. Jest to bardziej forma ochrony, ni\u017c pe\u0142ne ukrycie atrybut\u00f3w.</p> <pre><code>class MojaKlasa:\n    def __init__(self):\n        self.__ukryty_atrybut = \"tajne\"\n\n    def pokaz_ukryty(self):\n        return self.__ukryty_atrybut\n\nobiekt = MojaKlasa()\nprint(obiekt.pokaz_ukryty())  # Poprawne: \"tajne\"\nprint(obiekt._MojaKlasa__ukryty_atrybut)  # Dost\u0119p poprzez name mangling: \"tajne\"\n</code></pre> Po co u\u017cywa\u0107 atrybut\u00f3w pseudoprywatnych? <ul> <li>Ochrona przed przypadkowym nadpisaniem \u2013 przy dziedziczeniu klasy istnieje mniejsze ryzyko, \u017ce klasa pochodna przypadkowo nadpisze atrybut o tej samej nazwie.</li> <li>Czytelno\u015b\u0107 \u2013 pokazuj\u0105, \u017ce atrybut nie jest przeznaczony do bezpo\u015bredniego u\u017cytku z zewn\u0105trz klasy.</li> </ul>"},{"location":"zaj4/obiektowe/#rozszerzanie-typow-wbudowanych","title":"Rozszerzanie typ\u00f3w wbudowanych","text":"<p>Mo\u017ce by\u0107 przydatne, gdy chcemy doda\u0107 dodatkow\u0105 funkcjonalno\u015b\u0107 lub dostosowa\u0107 zachowanie istniej\u0105cych typ\u00f3w (np. <code>list</code>, <code>dict</code>, <code>str</code>) do specyficznych potrzeb projektu.</p>"},{"location":"zaj4/obiektowe/#za-pomoca-osadzania-kompozycja","title":"Za pomoc\u0105 osadzania (kompozycja)","text":"<p>Poprzez utworzenie nowej klasy, kt\u00f3ra wewn\u0119trznie przechowuje instancj\u0119 typu wbudowanego jako atrybut.</p> <p>W ten spos\u00f3b klasa ta mo\u017ce wykorzystywa\u0107 typ wbudowany i rozszerza\u0107 jego funkcjonalno\u015b\u0107, deleguj\u0105c operacje na ten typ, ale nie dziedziczy jego metod bezpo\u015brednio. Osadzanie jest przydatne, gdy chcemy doda\u0107 nowe funkcje bez ingerencji w istniej\u0105ce metody typu wbudowanego.</p> <pre><code>class MojaLista:\n    def __init__(self, elementy):\n        self._lista = elementy  # Osadzenie typu wbudowanego list\n\n    def suma(self):\n        return sum(self._lista)\n\n    def dodaj(self, element):\n        self._lista.append(element)\n\n    def __str__(self):\n        return str(self._lista)\n\nmoja_lista = MojaLista([1, 2, 3])\nmoja_lista.dodaj(4)\nprint(moja_lista)        # [1, 2, 3, 4]\nprint(moja_lista.suma()) # 10\n</code></pre>"},{"location":"zaj4/obiektowe/#za-pomoca-klas-podrzednych-dziedziczenia","title":"Za pomoc\u0105 klas podrz\u0119dnych (dziedziczenia)","text":"<p>Poprzez utworzenie klasy podrz\u0119dnej, kt\u00f3ra dziedziczy po typie wbudowanym. Dzi\u0119ki temu klasa podrz\u0119dna automatycznie przejmuje wszystkie metody i atrybuty typu bazowego, co pozwala na \u0142atwe dodanie nowych funkcji lub nadpisanie istniej\u0105cych metod.</p> <pre><code>class MojaLista(list):\n    def suma(self):\n        return sum(self)\n\nmoja_lista = MojaLista([1, 2, 3, 4])\nprint(moja_lista)         # [1, 2, 3, 4]\nprint(moja_lista.suma())  # 10\n</code></pre> Za i przeciw dla obu sposob\u00f3w Za Przeciw Osadzanie Daje pe\u0142n\u0105 kontrol\u0119 nad metodami, kt\u00f3re s\u0105 dost\u0119pne dla u\u017cytkownika klasy. Izoluje funkcjonalno\u015b\u0107 rozszerzonego typu od interfejsu klasy bazowej, co mo\u017ce zwi\u0119kszy\u0107 bezpiecze\u0144stwo i u\u0142atwi\u0107 utrzymanie kodu. Wymaga r\u0119cznego implementowania delegacji metod, je\u015bli potrzebujemy pe\u0142nego dost\u0119pu do funkcji typu wbudowanego. Mo\u017ce by\u0107 mniej wydajne i bardziej czasoch\u0142onne ni\u017c dziedziczenie, je\u015bli chcemy u\u017cywa\u0107 wi\u0119kszo\u015bci metod typu wbudowanego. Dziedziczenie Klasa pochodna automatycznie przejmuje wszystkie metody typu wbudowanego, co u\u0142atwia tworzenie nowych funkcji. Jest bardziej ekonomiczne i intuicyjne w implementacji, szczeg\u00f3lnie gdy potrzebujemy tylko kilku dodatkowych funkcji. Trudniej jest zmodyfikowa\u0107 spos\u00f3b dzia\u0142ania niekt\u00f3rych metod w typach wbudowanych, poniewa\u017c metody te mog\u0105 wywo\u0142ywa\u0107 bezpo\u015brednie operacje na strukturze danych. Dziedziczenie mo\u017ce prowadzi\u0107 do problem\u00f3w z nieoczekiwanym zachowaniem, je\u015bli metody typu wbudowanego nie s\u0105 dobrze przystosowane do nowych funkcji klasy pochodnej."},{"location":"zaj4/obiektowe/#sloty","title":"Sloty","text":"<p>Specjalny mechanizm, kt\u00f3ry pozwala na optymalizacj\u0119 pami\u0119ci obiekt\u00f3w klasy, poprzez ograniczenie listy atrybut\u00f3w, kt\u00f3re mo\u017cna doda\u0107 do instancji danej klasy.</p> <pre><code>class Osoba:\n    __slots__ = ['imie', 'wiek']  # Ograniczamy atrybuty tylko do 'imie' i 'wiek'\n\n    def __init__(self, imie, wiek):\n        self.imie = imie\n        self.wiek = wiek\n\nosoba = Osoba(\"Jan\", 30)\nprint(osoba.imie)  # Jan\nprint(osoba.wiek)  # 30\n\n# Pr\u00f3ba dodania nowego atrybutu zg\u0142osi b\u0142\u0105d\nosoba.adres = \"Warszawa\"  # AttributeError: 'Osoba' object has no attribute 'adres'\n</code></pre> <p>Python przestaje u\u017cywa\u0107 dynamicznego s\u0142ownika <code>__dict__</code> do przechowywania atrybut\u00f3w obiektu, co ogranicza mo\u017cliwo\u015b\u0107 dodawania nowych atrybut\u00f3w poza tymi zdefiniowanymi w <code>__slots__</code>, ale jednocze\u015bnie zmniejsza ilo\u015b\u0107 zu\u017cywanej pami\u0119ci.</p>"},{"location":"zaj4/obiektowe/#rodzaje-metod-w-klasach","title":"Rodzaje metod w klasach","text":""},{"location":"zaj4/obiektowe/#metody-instancji","title":"Metody instancji","text":"<p>Domy\u015blny spos\u00f3b dzia\u0142ania, jako pierwszy argument przyjmuj\u0105 <code>self</code>, kt\u00f3ry odnosi si\u0119 do instancji.</p> Zastosowanie <p>Operacje na instancji.</p>"},{"location":"zaj4/obiektowe/#metody-klasy","title":"Metody klasy","text":"<p>Deklarowane za pomoc\u0105 dekoratora <code>@classmethod</code>. Przyjmuj\u0105 jako pierwszy argument <code>cls</code>, kt\u00f3ry odnosi si\u0119 do samej klasy, a nie jej instancji.</p> <pre><code>class Pracownik:\n    liczba_pracownikow = 0  # Atrybut klasy\n\n    def __init__(self, imie, stanowisko):\n        self.imie = imie\n        self.stanowisko = stanowisko\n        Pracownik.liczba_pracownikow += 1\n\n    @classmethod\n    def z_nazwiska(cls, nazwisko):\n        # Alternatywny konstruktor\n        return cls(nazwisko, 'Nieznane stanowisko')\n\n    @classmethod\n    def ustaw_liczbe_pracownikow(cls, liczba):\n        cls.liczba_pracownikow = liczba\n\n# Tworzenie instancji za pomoc\u0105 metody klasy\nnowy_pracownik = Pracownik.z_nazwiska('Kowalski')\nprint(nowy_pracownik.imie)           # Kowalski\nprint(nowy_pracownik.stanowisko)     # Nieznane stanowisko\n</code></pre> Zastosowanie <p>Operacje na klasie, alternatywne konstruktory.</p>"},{"location":"zaj4/obiektowe/#metody-statyczne","title":"Metody statyczne","text":"<p>Deklarowane za pomoc\u0105 dekoratora <code>@staticmethod</code>. Nie przyjmuj\u0105 \u017cadnego specjalnego pierwszego argumentu i nie maj\u0105 dost\u0119pu ani do instancji (<code>self</code>), ani do klasy (<code>cls</code>).</p> <pre><code>class Kalkulator:\n    @staticmethod\n    def dodaj(a, b):\n        return a + b\n\n    @staticmethod\n    def odejmij(a, b):\n        return a - b\n\n# Wywo\u0142ywanie metod statycznych\nprint(Kalkulator.dodaj(5, 3))     # 8\nprint(Kalkulator.odejmij(10, 4))  # 6\n</code></pre> Zastosowanie <p>Funkcje pomocnicze powi\u0105zane tematycznie.</p>"},{"location":"zaj4/obiektowe/#zadanie_1","title":"Zadanie","text":"<p>Zapoznaj si\u0119 z metodami w klasie z <code>src.zajecia04.fleet.ambulance</code>.</p>"},{"location":"zaj4/obiektowe/#zadania","title":"Zadania","text":"<p>Dodaj nast\u0119puj\u0105ce funkcjonalno\u015bci do programu przedstawionego jako przyk\u0142ad. Dla wszystkich dodanych funkcjonalno\u015bci stw\u00f3rz przyk\u0142adowy kod potwierdzaj\u0105cy, \u017ce dzia\u0142aj\u0105 (rozbudowuj\u0105c kod w <code>run_zajecia04.py</code>).</p> <ol> <li>Zmodyfikuj ka\u017cd\u0105 klas\u0119 tak, \u017ceby posiada\u0142a atrybut <code>__max_id</code>, kt\u00f3ry b\u0119dzie wykorzystywany do nadawania identyfikator\u00f3w kolejnym stworzonym instancjom (zamiast podawania go jako argument przy inicjalizacji). </li> <li>Rozbuduj klas\u0119 Incident o priorytet zdarzenia, czas zg\u0142oszenia i informacje o zg\u0142aszaj\u0105cym. </li> <li>Zaprojektuj w ramach subpakietu <code>fleet</code> klas\u0119 <code>Station</code>, ka\u017cda stacja ma posiada\u0107 identyfikator, lokalizacj\u0119, karetk\u0119, kierowc\u0119 i 1 dodatkowego pracownika. Napisz metod\u0119, kt\u00f3ra sprawdza czy karetka jest na miejscu (czy zgadzaj\u0105 si\u0119 lokalizacje). </li> <li> <p>Rozbuduj aplikacj\u0119 (w tym zaprojektuj logik\u0119, ale tak\u017ce elementy, kt\u00f3re trzeba doda\u0107 w r\u00f3\u017cnych klasach (niekoniecznie istniej\u0105cych) o mo\u017cliwo\u015b\u0107 zarz\u0105dzania incydentami \u2013 przydzielanie karetek do zg\u0142aszanych zdarze\u0144. Te funkcjonalno\u015bci musz\u0105 uwzgl\u0119dnia\u0107: </p> <ul> <li>Priorytet i czas, kt\u00f3ry up\u0142yn\u0105\u0142 od zg\u0142oszenia, </li> <li>Aktualny stan, w kt\u00f3rym znajduje si\u0119 karetka, </li> <li>Odleg\u0142o\u015b\u0107 karetki od zdarzenia.</li> </ul> </li> </ol>"},{"location":"zaj5/dekoratory/","title":"Dekoratory","text":"<p>Dekoratory to specjalne funkcje, kt\u00f3re pozwalaj\u0105 na rozszerzanie funkcjonalno\u015bci innych funkcji lub klas bez modyfikacji ich kodu. Umo\u017cliwiaj\u0105 one dodanie dodatkowego dzia\u0142ania przed lub po wykonaniu oryginalnej funkcji, co jest przydatne w wielu scenariuszach, takich jak logowanie, uwierzytelnianie, zarz\u0105dzanie czasem wykonania funkcji itp.</p>"},{"location":"zaj5/dekoratory/#podstawowe-dziaanie","title":"Podstawowe dzia\u0142anie","text":"<p>Dekorator to funkcja, kt\u00f3ra przyjmuje inn\u0105 funkcj\u0119 jako argument i zwraca now\u0105 funkcj\u0119, kt\u00f3ra rozszerza dzia\u0142anie oryginalnej. Dzi\u0119ki temu mo\u017cemy doda\u0107 dodatkow\u0105 funkcjonalno\u015b\u0107 bez modyfikowania cia\u0142a dekorowanej funkcji.</p> <pre><code>def przykladowy_dekorator(funkcja):\n    def wrapper():\n        print(\"Dodatkowa funkcjonalno\u015b\u0107 przed wywo\u0142aniem funkcji.\")\n        funkcja()\n        print(\"Dodatkowa funkcjonalno\u015b\u0107 po wywo\u0142aniu funkcji.\")\n    return wrapper\n</code></pre>"},{"location":"zaj5/dekoratory/#dekorowanie-funkcji","title":"Dekorowanie funkcji","text":"<p>Aby zastosowa\u0107 dekorator, mo\u017cna go \u201eprzyklei\u0107\u201d do funkcji za pomoc\u0105 znaku <code>@</code>.</p> <pre><code>@przykladowy_dekorator\ndef moja_funkcja():\n    print(\"Oryginalna funkcja.\")\n\nmoja_funkcja()\n</code></pre>"},{"location":"zaj5/dekoratory/#dekorator-z-argumentami-funkcji","title":"Dekorator z argumentami funkcji","text":"<p>Aby stworzy\u0107 dekorator, kt\u00f3ry obs\u0142u\u017cy funkcje z argumentami, wystarczy zmodyfikowa\u0107 wewn\u0119trzn\u0105 funkcj\u0119 <code>wrapper</code>, aby przyjmowa\u0142a dowolne argumenty i przekazywa\u0142a je do oryginalnej funkcji.</p> <pre><code>def przykladowy_dekorator(funkcja):\n    def wrapper(*args, **kwargs):\n        print(\"Przed wywo\u0142aniem funkcji.\")\n        wynik = funkcja(*args, **kwargs)\n        print(\"Po wywo\u0142aniu funkcji.\")\n        return wynik\n    return wrapper\n\n@przykladowy_dekorator\ndef dodaj(a, b):\n    return a + b\n\nprint(dodaj(3, 5))\n</code></pre>"},{"location":"zaj5/dekoratory/#dekorowanie-klas","title":"Dekorowanie klas","text":"<p>Dekoratory mog\u0105 by\u0107 r\u00f3wnie\u017c stosowane do ca\u0142ych klas, modyfikuj\u0105c ich zachowanie lub dodaj\u0105c dodatkowe funkcje. Dekorator klasy przyjmuje klas\u0119 jako argument i zwraca zmodyfikowan\u0105 wersj\u0119 tej klasy.</p> <pre><code>def dodaj_metode(cls):\n    cls.nowa_metoda = lambda self: \"Nowa metoda w klasie!\"\n    return cls\n\n@dodaj_metode\nclass MojaKlasa:\n    def __init__(self):\n        self.wartosc = 42\n\n# Tworzenie instancji i u\u017cycie dodanej metody\nobiekt = MojaKlasa()\nprint(obiekt.nowa_metoda())  # Nowa metoda w klasie!\n</code></pre>"},{"location":"zaj5/dekoratory/#typowe-zastosowania-dekoratorow","title":"Typowe zastosowania dekorator\u00f3w","text":"Logowanie <p>Logowanie - automatyczne logowanie wywo\u0142a\u0144 funkcji.</p> <pre><code>def loguj(funkcja):\n    def wrapper(*args, **kwargs):\n        print(f\"Wywo\u0142ano funkcj\u0119: {funkcja.__name__} z argumentami: {args}, {kwargs}\")\n        return funkcja(*args, **kwargs)\n    return wrapper\n</code></pre> Uwierzytelnianie <p>Uwierzytelnianie \u2013 sprawdzanie uprawnie\u0144 przed wykonaniem funkcji.</p> <pre><code>def wymaga_uprawnien(funkcja):\n    def wrapper(*args, **kwargs):\n        if not uzytkownik_ma_uprawnienia():\n            raise PermissionError(\"Brak uprawnie\u0144!\")\n        return funkcja(*args, **kwargs)\n    return wrapper\n</code></pre> Mierzenie czasu wykonania funkcji <p>Czas wykonania funkcji \u2013 pomiar czasu, jaki zajmuje wykonanie funkcji.</p> <pre><code>import time\n\ndef zmierz_czas(funkcja):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        wynik = funkcja(*args, **kwargs)\n        end = time.time()\n        print(f\"Czas wykonania: {end - start} sekund\")\n        return wynik\n    return wrapper\n</code></pre>"},{"location":"zaj5/dekoratory/#zadania","title":"Zadania","text":"<p>Stw\u00f3rz program (to r\u00f3wnie\u017c mo\u017ce by\u0107 po prostu jeden plik), w kt\u00f3rym zdefiniujesz dekorator oraz przedstawisz jego dzia\u0142anie. </p> <p>Ma to by\u0107 dekorator, kt\u00f3ry zmierzy i wy\u015bwietli czas wykonania dekorowanej funkcji. Dekorator powinien przyjmowa\u0107 jeden argument, kt\u00f3ry okre\u015bla jednostk\u0119 czasu (sekundy lub mikrosekundy) dla wyniku. </p> <p>Wymagania: </p> <ul> <li>Ma przyjmowa\u0107 argument o nazwie unit o warto\u015bci 'seconds' lub 'microseconds', okre\u015blaj\u0105cy jednostk\u0119, w kt\u00f3rej ma by\u0107 wy\u015bwietlony czas wykonania funkcji. </li> <li>Ma mierzy\u0107 czas wykonania dekorowanej funkcji. </li> <li>Ma wy\u015bwietli\u0107 czas wykonania funkcji w wybranej jednostce po zako\u0144czeniu jej wykonania. </li> </ul>"},{"location":"zaj5/menadzery_kontekstu/","title":"Menad\u017cery kontekstu","text":"<p>S\u0105 to narz\u0119dzia, kt\u00f3re pomagaj\u0105 w zarz\u0105dzaniu zasobami, takimi jak pliki, po\u0142\u0105czenia sieciowe, czy po\u0142\u0105czenia z bazami danych. Dzi\u0119ki menad\u017cerom kontekstu mo\u017cna upewni\u0107 si\u0119, \u017ce zasoby zostan\u0105 poprawnie otwarte, a nast\u0119pnie zamkni\u0119te \u2013 nawet je\u015bli w trakcie korzystania z zasobu wyst\u0105pi wyj\u0105tek.</p>"},{"location":"zaj5/menadzery_kontekstu/#instrukcja-with","title":"Instrukcja <code>with</code>","text":"<p>Python zapewnia obs\u0142ug\u0119 menad\u017cer\u00f3w kontekstu za pomoc\u0105 instrukcji <code>with</code>, kt\u00f3ra gwarantuje poprawne zarz\u0105dzanie zasobami. Gdy u\u017cywamy <code>with</code>, zas\u00f3b jest automatycznie otwierany i zamykany, co zmniejsza ryzyko wyciek\u00f3w pami\u0119ci i innych b\u0142\u0119d\u00f3w wynikaj\u0105cych z niezamkni\u0119cia zasob\u00f3w.</p> <pre><code>with open(\"plik.txt\", \"w\") as plik:\n    plik.write(\"Witaj, \u015bwiecie!\")\n</code></pre>"},{"location":"zaj5/menadzery_kontekstu/#tworzenie-wasnych-menadzerow-kontekstu","title":"Tworzenie w\u0142asnych menad\u017cer\u00f3w kontekstu","text":"<p>Aby utworzy\u0107 w\u0142asny menad\u017cer kontekstu, wystarczy zdefiniowa\u0107 klas\u0119 z dwiema metodami:</p> <ul> <li><code>__enter__</code> \u2013 ta metoda jest wywo\u0142ywana na pocz\u0105tku bloku <code>with</code> i powinna zwraca\u0107 zas\u00f3b, kt\u00f3rym b\u0119dziemy zarz\u0105dza\u0107.</li> <li><code>__exit__</code> \u2013 ta metoda jest wywo\u0142ywana na ko\u0144cu bloku <code>with</code> i s\u0142u\u017cy do czyszczenia zasobu (np. zamkni\u0119cia go), bez wzgl\u0119du na to, czy wyst\u0105pi\u0142 wyj\u0105tek.</li> </ul> <p>Jako przyk\u0142ad, menad\u017cer kontekstu dla po\u0142\u0105czenia z baz\u0105 danych:</p> <pre><code>class PolaczenieBazaDanych:\n    def __enter__(self):\n        print(\"Nawi\u0105zywanie po\u0142\u0105czenia z baz\u0105 danych...\")\n        # Symulacja po\u0142\u0105czenia, np. self.conn = connect_to_database()\n        self.polaczenie = \"Po\u0142\u0105czenie aktywne\"\n        return self.polaczenie\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        print(\"Zamykanie po\u0142\u0105czenia z baz\u0105 danych...\")\n        # Symulacja zamkni\u0119cia po\u0142\u0105czenia, np. self.conn.close()\n        self.polaczenie = None\n\n# U\u017cycie menad\u017cera kontekstu\nwith PolaczenieBazaDanych() as polaczenie:\n    print(polaczenie)\n    # Wykonanie operacji na bazie danych\n</code></pre>"},{"location":"zaj5/menadzery_kontekstu/#obsuga-wyjatkow-w-__exit__","title":"Obs\u0142uga wyj\u0105tk\u00f3w w <code>__exit__</code>","text":"<p>Metoda <code>__exit__</code> otrzymuje trzy argumenty: <code>exc_type</code>, <code>exc_value</code> i <code>traceback</code>, kt\u00f3re s\u0105 zwi\u0105zane z wyj\u0105tkiem, kt\u00f3ry m\u00f3g\u0142 wyst\u0105pi\u0107 wewn\u0105trz bloku <code>with</code>. Mo\u017cemy dzi\u0119ki nim obs\u0142u\u017cy\u0107 wyj\u0105tek wewn\u0105trz <code>__exit__</code> lub po prostu pozwoli\u0107, aby wyj\u0105tek zosta\u0142 propagowany dalej.</p> <pre><code>class PolaczenieBazaDanych:\n    def __enter__(self):\n        print(\"Nawi\u0105zywanie po\u0142\u0105czenia z baz\u0105 danych...\")\n        self.polaczenie = \"Po\u0142\u0105czenie aktywne\"\n        return self.polaczenie\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type:\n            print(f\"Wyst\u0105pi\u0142 wyj\u0105tek: {exc_value}\")\n        print(\"Zamykanie po\u0142\u0105czenia z baz\u0105 danych...\")\n        self.polaczenie = None\n\n# U\u017cycie menad\u017cera kontekstu z wyj\u0105tkiem\ntry:\n    with PolaczenieBazaDanych() as polaczenie:\n        print(polaczenie)\n        raise ValueError(\"Symulowany b\u0142\u0105d!\")\nexcept ValueError:\n    print(\"Obs\u0142u\u017cono wyj\u0105tek!\")\n</code></pre>"},{"location":"zaj5/wyjatki/","title":"Wyj\u0105tki","text":"<p>S\u0105 to b\u0142\u0119dy, kt\u00f3re wyst\u0119puj\u0105 podczas wykonywania programu i mog\u0105 powodowa\u0107 jego nag\u0142e zako\u0144czenie, je\u015bli nie s\u0105 odpowiednio obs\u0142u\u017cone.</p> <p>Zarz\u0105dzanie wyj\u0105tkami, czyli kontrola nad tym, jak program zachowuje si\u0119 w sytuacji, gdzy wyst\u0105pi b\u0142\u0105d, obejmuje wykorzystanie s\u0142\u00f3w kluczowych <code>try</code>, <code>except</code>, <code>else</code> i <code>finally</code> oraz r\u0119czne wywo\u0142ywanie wyj\u0105tk\u00f3w za pomoc\u0105 <code>raise</code>.</p>"},{"location":"zaj5/wyjatki/#podstawowa-obsuga-wyjatkow","title":"Podstawowa obs\u0142uga wyj\u0105tk\u00f3w","text":"<p>Podstawowy blok obs\u0142ugi wyj\u0105tk\u00f3w sk\u0142ada si\u0119 z <code>try</code> i <code>except</code>. </p> <ul> <li>W bloku <code>try</code> umieszczamy kod, kt\u00f3ry mo\u017ce wywo\u0142a\u0107 wyj\u0105tek,</li> <li>a blok <code>except</code> przechwytuje ten wyj\u0105tek i wykonuje odpowiednie dzia\u0142ania.</li> </ul> <pre><code>try:\n    liczba = int(input(\"Podaj liczb\u0119: \"))\n    wynik = 10 / liczba\n    print(f\"Wynik: {wynik}\")\nexcept ZeroDivisionError:\n    print(\"Nie mo\u017cna dzieli\u0107 przez zero!\")\nexcept ValueError:\n    print(\"To nie jest poprawna liczba!\")\n</code></pre> <p>Dodatkowo, je\u015bli chcemy mie\u0107 mo\u017cliwo\u015b\u0107 dost\u0119pu do tre\u015bci b\u0142\u0119du, mo\u017cna stosowa\u0107 nast\u0119puj\u0105cy zapis:</p> <pre><code>try:\n    liczba = int(input(\"Podaj liczb\u0119: \"))\n    wynik = 10 / liczba\n    print(f\"Wynik: {wynik}\")\nexcept Exception as e:\n    print(f\"Wyst\u0105pi\u0142 b\u0142\u0105d: {e}\")\n</code></pre>"},{"location":"zaj5/wyjatki/#dodatkowe-bloki-else-i-finally","title":"Dodatkowe bloki <code>else</code> i <code>finally</code>","text":"<ul> <li>Kod w bloku <code>else</code> wykona si\u0119 tylko wtedy, gdy \u017caden wyj\u0105tek nie zosta\u0142 wywo\u0142any w bloku <code>try</code>.</li> <li>Blok <code>finally</code> wykona si\u0119 zawsze, niezale\u017cnie od tego, czy wyj\u0105tek wyst\u0105pi\u0142, czy nie. Zazwyczaj u\u017cywany jest do zamykania zasob\u00f3w lub wykonania czynno\u015bci ko\u0144cowych.</li> </ul> <pre><code>try:\n    liczba = int(input(\"Podaj liczb\u0119: \"))\n    wynik = 10 / liczba\nexcept ZeroDivisionError:\n    print(\"Nie mo\u017cna dzieli\u0107 przez zero!\")\nexcept ValueError:\n    print(\"To nie jest poprawna liczba!\")\nelse:\n    print(f\"Wynik: {wynik}\")\nfinally:\n    print(\"To by\u0142 przyk\u0142ad obs\u0142ugi wyj\u0105tk\u00f3w.\")\n</code></pre>"},{"location":"zaj5/wyjatki/#reczne-wywoywanie-wyjatkow-raise","title":"R\u0119czne wywo\u0142ywanie wyj\u0105tk\u00f3w - <code>raise</code>","text":"<pre><code>def sprawdz_wiek(wiek):\n    if wiek &lt; 18:\n        raise ValueError(\"Wiek musi by\u0107 co najmniej 18 lat.\")\n    return \"Dost\u0119p dozwolony\"\n\ntry:\n    print(sprawdz_wiek(15))\nexcept ValueError as e:\n    print(f\"B\u0142\u0105d: {e}\")\n</code></pre> <p>Wi\u0119kszo\u015b\u0107 wyj\u0105tk\u00f3w to klasy wbudowane, kt\u00f3re s\u0105 dost\u0119pne bezpo\u015brednio w standardowej bibliotece. Mo\u017cna je znale\u017a\u0107 w dokumentacji.</p> Najcz\u0119\u015bciej wykorzystywane wyj\u0105tki <p>Te najcz\u0119\u015bciej wykorzystywane to np.:</p> <ul> <li><code>ValueError</code> - gdy argument ma poprawny typ, ale niepoprawn\u0105 warto\u015b\u0107.</li> <li><code>TypeError</code> - gdy argument jest niepoprawnego typu.</li> <li><code>IndexError</code>- gdy indeks jest poza zakresem listy, krotki itp.</li> <li><code>KeyError</code> - gdy klucz nie istnieje w s\u0142owniku.</li> <li><code>AttributeError</code> - gdy obiekt nie ma okre\u015blonego atrybutu.</li> <li><code>FileNotFoundError</code> - gdy okre\u015blony plik nie istnieje.</li> <li><code>ZeroDivisionError</code> - gdy wyst\u0119puje pr\u00f3ba dzielenia przez zero.</li> <li><code>PermissionError</code> - gdy brak jest uprawnie\u0144 do wykonania operacji, np. przy otwieraniu pliku.</li> <li><code>RuntimeError</code> - wyj\u0105tek og\u00f3lny, stosowany w nietypowych sytuacjach, gdy \u017caden inny wyj\u0105tek nie jest odpowiedni.</li> <li><code>NotImplementedError</code> - gdy metoda jest zamierzona do implementacji w przysz\u0142o\u015bci (u\u017cywany np. w metodach abstrakcyjnych).</li> <li><code>OverflowError</code> - gdy wynik operacji matematycznej jest zbyt du\u017cy do przetworzenia.</li> <li><code>ImportError</code> - gdy nie uda si\u0119 zaimportowa\u0107 modu\u0142u lub elementu z modu\u0142u.</li> <li><code>AssertionError</code> - gdy <code>assert</code> sprawdzenie ko\u0144czy si\u0119 niepowodzeniem.</li> </ul>"},{"location":"zaj5/wyjatki/#tworzenie-wasnych-wyjatkow","title":"Tworzenie w\u0142asnych wyj\u0105tk\u00f3w","text":"<p>Zbudowane s\u0105 na bazie klas, co pozwala na tworzenie w\u0142asnych, spersonalizowanych wyj\u0105tk\u00f3w poprzez dziedziczenie (najcz\u0119\u015bciej po klasie <code>Exception</code>).</p> <p>Dzi\u0119ki temu mo\u017cna definiowa\u0107 specyficzne b\u0142\u0119dy, kt\u00f3re s\u0105 bardziej dopasowane do konkretnego kontekstu aplikacji. Tworzenie w\u0142asnych wyj\u0105tk\u00f3w pomaga r\u00f3wnie\u017c w precyzyjniejszym zarz\u0105dzaniu b\u0142\u0119dami i zapewnia bardziej czytelny kod.</p> <p>Aby stworzy\u0107 w\u0142asny wyj\u0105tek, definiujemy now\u0105 klas\u0119, kt\u00f3ra dziedziczy po <code>Exception</code> lub jednej z jej klas pochodnych. Mo\u017cemy tak\u017ce doda\u0107 do tej klasy specjalne atrybuty czy metody, kt\u00f3re b\u0119d\u0105 specyficzne dla naszego b\u0142\u0119du.</p> Prosty przyk\u0142ad <pre><code>class BrakSrodkowError(Exception):\n    \"\"\"Wyj\u0105tek sygnalizuj\u0105cy brak wystarczaj\u0105cych \u015brodk\u00f3w na koncie.\"\"\"\n    pass\n\nclass KontoBankowe:\n    def __init__(self, saldo=0):\n        self.saldo = saldo\n\n    def wyplac(self, kwota):\n        if kwota &gt; self.saldo:\n            raise BrakSrodkowError(f\"Brak wystarczaj\u0105cych \u015brodk\u00f3w: saldo {self.saldo} z\u0142, potrzebne {kwota} z\u0142\")\n        self.saldo -= kwota\n        print(f\"Wyp\u0142acono {kwota}. Aktualne saldo: {self.saldo}\")\n\n# Przyk\u0142ad u\u017cycia\nkonto = KontoBankowe(100)\n\ntry:\n    konto.wyplac(150)\nexcept BrakSrodkowError as e:\n    print(f\"B\u0142\u0105d: {e}\")\n</code></pre> Bardziej skomplikowany przyk\u0142ad <pre><code>class BladZakresu(Exception):\n    def __init__(self, wartosc, zakres_min, zakres_max):\n        super().__init__(f\"Warto\u015b\u0107 {wartosc} jest poza dozwolonym zakresem ({zakres_min} - {zakres_max}).\")\n        self.wartosc = wartosc\n        self.zakres_min = zakres_min\n        self.zakres_max = zakres_max\n\ndef sprawdz_zakres(wartosc):\n    if not (0 &lt;= wartosc &lt;= 100):\n        raise BladZakresu(wartosc, 0, 100)\n\ntry:\n    sprawdz_zakres(150)\nexcept BladZakresu as e:\n    print(f\"B\u0142\u0105d: {e}\")\n    print(f\"Szczeg\u00f3\u0142y: Warto\u015b\u0107 = {e.wartosc}, Zakres = ({e.zakres_min} - {e.zakres_max})\")\n</code></pre>"},{"location":"zaj5/wyjatki/#hierarchia-wyjatkow","title":"Hierarchia wyj\u0105tk\u00f3w","text":"<p>Tworzenie w\u0142asnych wyj\u0105tk\u00f3w daje r\u00f3wnie\u017c mo\u017cliwo\u015b\u0107 tworzenia hierarchii wyj\u0105tk\u00f3w. Mo\u017cna stworzy\u0107 og\u00f3ln\u0105 klas\u0119 wyj\u0105tku, po kt\u00f3rej dziedzicz\u0105 bardziej szczeg\u00f3\u0142owe klasy wyj\u0105tk\u00f3w, co pozwala na precyzyjniejsze zarz\u0105dzanie b\u0142\u0119dami.</p> <pre><code>class BladAplikacji(Exception):\n    pass\n\nclass BladPolaczenia(BladAplikacji):\n    pass\n\nclass BladAutoryzacji(BladAplikacji):\n    pass\n\ntry:\n    raise BladPolaczenia(\"B\u0142\u0105d podczas \u0142\u0105czenia z serwerem.\")\nexcept BladAplikacji as e:\n    print(f\"B\u0142\u0105d aplikacji: {e}\")\n</code></pre> <p><code>BladAplikacji</code> jest og\u00f3lnym wyj\u0105tkiem aplikacji, a <code>BladPolaczenia</code> i <code>BladAutoryzacji</code> dziedzicz\u0105 po nim.</p> <p>Blok except <code>BladAplikacji</code> przechwytuje ka\u017cdy wyj\u0105tek pochodny od <code>BladAplikacji</code>, co daje elastyczno\u015b\u0107 w obs\u0142udze b\u0142\u0119d\u00f3w.</p> Zapis <code>except Exception as e</code> <p>To samo dzieje si\u0119 w podstawowym zapisie <code>except Exception as e:</code>, kt\u00f3ry przechwytuje wszystkie wyj\u0105tki. T\u0142umaczy to dlaczego wszystkie nasze wyj\u0105tki powinny dziedziczy\u0107 po klasie <code>Exception</code>.</p>"},{"location":"zaj5/wyjatki/#zadania","title":"Zadania","text":"<ol> <li> <p>Napisz program w Pythonie (w tym wypadku mo\u017ce to by\u0107 po prostu jeden plik), kt\u00f3ry:</p> <ul> <li>B\u0119dzie przechowywa\u0142 informacje o dost\u0119pnych miejscach na sali kinowej (mo\u017ce to by\u0107 np. s\u0142ownik czy macierz),</li> <li>Umo\u017cliwi rezerwacj\u0119 konkretnego miejsca (np. A2), a tak\u017ce anulowanie rezerwacji,</li> <li>Logika rezerwacji:<ul> <li>Je\u015bli na seans nie ma ju\u017c miejsc, zg\u0142o\u015b wyj\u0105tek,</li> <li>Je\u015bli u\u017cytkownik pr\u00f3buje zarezerwowa\u0107 miejsce, kt\u00f3re ju\u017c jest zarezerwowane, zg\u0142o\u015b wyj\u0105tek,</li> <li>Je\u015bli ten sam u\u017cytkownik (zachowaj informacje o u\u017cytkowniku, czyli np. imi\u0119 i nazwisko) pr\u00f3buje ponownie zarezerwowa\u0107 miejsce (zak\u0142adamy, \u017ce jeden u\u017cytkownik mo\u017ce zarezerwowa\u0107 tylko 1 miejsce), zg\u0142o\u015b wyj\u0105tek,</li> <li>W przeciwnym razie zarezerwuj miejsce.</li> </ul> </li> <li>Logika anulacji:<ul> <li>Je\u015bli zgadza si\u0119 numer miejsca oraz u\u017cytkownik, anuluj rezerwacj\u0119,</li> <li>W ka\u017cdym innym przypadku, zg\u0142o\u015b wyj\u0105tek.</li> </ul> </li> </ul> </li> </ol> Uwaga <p>W zadaniu u\u017cyj zar\u00f3wno obs\u0142ugi wyjatk\u00f3w jak i w\u0142asnor\u0119cznie zdefiniowanych wyj\u0105tk\u00f3w.</p>"}]}